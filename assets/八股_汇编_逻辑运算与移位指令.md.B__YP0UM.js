import{_ as a,c as s,o as n,a6 as l}from"./chunks/framework.DkFL-jqo.js";const g=JSON.parse('{"title":"逻辑运算指令","description":"","frontmatter":{},"headers":[],"relativePath":"八股/汇编/逻辑运算与移位指令.md","filePath":"八股/汇编/逻辑运算与移位指令.md"}'),p={name:"八股/汇编/逻辑运算与移位指令.md"},e=l(`<h1 id="逻辑运算指令" tabindex="-1">逻辑运算指令 <a class="header-anchor" href="#逻辑运算指令" aria-label="Permalink to &quot;逻辑运算指令&quot;">​</a></h1><h2 id="求-反-指令not" tabindex="-1">求“反”指令NOT <a class="header-anchor" href="#求-反-指令not" aria-label="Permalink to &quot;求“反”指令NOT&quot;">​</a></h2><p><code>NOT OPD</code></p><ul><li><p>功能：将目的地址中的内容逐位取反后送入目的地址</p></li><li><p>NOT指令对状态标志位无影响。</p></li><li><p>eg:</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> MOV AX，878AH    ;(AX)=878AH</span></span>
<span class="line"><span> NOT AX   ;(AX)=7875H</span></span></code></pre></div></li></ul><h2 id="逻辑-与-指令and" tabindex="-1">逻辑“与”指令AND <a class="header-anchor" href="#逻辑-与-指令and" aria-label="Permalink to &quot;逻辑“与”指令AND&quot;">​</a></h2><p><code>AND OPD， OPS</code></p><ul><li><p>功能：将目的操作数和源操作数按位进行逻 辑“与”运算，结果存目的地址</p></li><li><p>状态标志位的影响：OF和CF清0</p><ul><li><p>eg:</p></li><li><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>某个操作数与本身进行“与”运算：</span></span>
<span class="line"><span>AND AL，AL</span></span>
<span class="line"><span>结果：操作数本身显然不变，经常用于将进位标志位CF清“0”。</span></span></code></pre></div></li></ul></li><li><p>AND指令常常用于对目的操作数中的指定一位或多位清0</p><ul><li><p>eg:</p></li><li><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>分析指令功能：AND    AX，0FFH</span></span>
<span class="line"><span>结果：AX高8位(AH)被清“0”，而AX低8位(AL)值不变。</span></span></code></pre></div></li></ul></li></ul><h2 id="逻辑或指令or" tabindex="-1">逻辑或指令OR <a class="header-anchor" href="#逻辑或指令or" aria-label="Permalink to &quot;逻辑或指令OR&quot;">​</a></h2><p><code>OR OPD，OPS</code></p><ul><li><p>功能：目的操作数和源操作数进行逻辑 “或”运算，结果存目的地址，即 (OPD)∨(OPS)→OPD。</p></li><li><p>状态标志位的影响：OF和CF清0</p></li><li><p>OR指令常常用于对目的操作数中的指定一位或多位 置1</p><ul><li><p>eg:</p></li><li><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>将AL寄存器中第3位和第7位置1。</span></span>
<span class="line"><span>OR AL，88H</span></span></code></pre></div></li></ul></li><li><p>类似于AND指令，某个操作数与本身进行或运算：</p><ul><li><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>OR AX ，AX</span></span>
<span class="line"><span>操作的结果是：操作数不变，但使CF清“0”。</span></span></code></pre></div></li></ul></li></ul><h2 id="异或xor指令" tabindex="-1">异或XOR指令 <a class="header-anchor" href="#异或xor指令" aria-label="Permalink to &quot;异或XOR指令&quot;">​</a></h2><p><code>XOR OPD，OPS</code></p><ul><li><p>功能：目的操作数与源操作数做按位异或运算，结 果送入目的地址，即：(OPD)⊕(OPS) →OPD。</p></li><li><p>状态标志位的影响：OF和CF清0</p></li><li><p>异或运算也可称为“按位加/减”</p><ul><li><p>eg:将AL寄存器中第3位和第7位取反</p></li><li><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>XOR AL， 88H</span></span></code></pre></div></li></ul></li><li><p>按位加运算</p><ul><li><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>MOV AL，45H ;(AL)=45H</span></span>
<span class="line"><span>XOR AL，31H ;(AL)=74H</span></span></code></pre></div></li></ul></li><li><p>源、目不允许同为内存操作数。</p></li><li><p>当源为立即数，目为内存操作数时，须用 PTR说明目属性。</p></li></ul><h2 id="测试指令test" tabindex="-1">测试指令TEST <a class="header-anchor" href="#测试指令test" aria-label="Permalink to &quot;测试指令TEST&quot;">​</a></h2><p><code>TEST OPD，OPS</code></p><ul><li><p>状态标志影响情况与AND、OR、XOR相同</p><ul><li>CF、OF清0</li></ul></li><li><p>影响ZF、SF、PF</p></li><li><p>该指令常与条件转移指令配合使用，以决定 程序的转移方向。</p><ul><li><p>eg:测试AX中的第12位是否为0，如果为0则 跳转至NEXT。</p></li><li><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>TEST  AX，1000H    ;0001 0000 0000 0000B</span></span>
<span class="line"><span>JZ NEXT</span></span></code></pre></div></li></ul></li></ul><h1 id="移位指令" tabindex="-1">移位指令 <a class="header-anchor" href="#移位指令" aria-label="Permalink to &quot;移位指令&quot;">​</a></h1><blockquote><ol><li><p>移位次数由指令中的计数值所决定，可以是1次或由存放在CL中的无符号数指定。</p><p>这些指令均有统一的 指令格式：</p><ul><li>操作码 OPD，1 (8086／8088)</li><li>或 操作码 OPD，CL (80X86)</li></ul></li><li><p>移位指令包括算术移位指令、逻辑移位指令 和循环移位指令</p></li><li><p>任何一条移位指令最后移出的1位二进制数总 是存入CF中。</p></li><li><p>可以利用移位指令来实现快速的乘除法， 比直接使用乘除指令快。</p><ul><li>逻辑移位指令实现无符号数乘、除法 运算,只要移出位不含1</li><li>算术移位指令实现有符号数乘除法运 算，只要移位操作不改变符号位</li></ul><p>eg:</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>;某数乘4或除4的运算。</span></span>
<span class="line"><span>MOV   CL，2</span></span>
<span class="line"><span>SHL    AX ，CL      ;AX中的无符号数乘4</span></span>
<span class="line"><span>SHR    AX， CL      ;无符号数除以4</span></span>
<span class="line"><span>SAR    AX， CL      ;有符号数除以4</span></span></code></pre></div></li></ol></blockquote><h2 id="算术左移sal和逻辑左移指令shl" tabindex="-1">算术左移SAL和逻辑左移指令SHL <a class="header-anchor" href="#算术左移sal和逻辑左移指令shl" aria-label="Permalink to &quot;算术左移SAL和逻辑左移指令SHL&quot;">​</a></h2><p><code>SHL(SAL) OPD，1 或 SHL(SAL) OPD，CL</code></p><ul><li>功能：SHL与SAL指令功能完全相同。</li><li>将(OPD)向左移动1次或者CL指定的次数，最 低位补入相应的0，CF的内容为最后移出位的值。</li><li>用SAL/SHL指令可以实现对无符号数乘以2^n^ 的运算(n为移位次数)、但需注意溢出(CF)</li></ul><h2 id="逻辑右移指令shr" tabindex="-1">逻辑右移指令SHR <a class="header-anchor" href="#逻辑右移指令shr" aria-label="Permalink to &quot;逻辑右移指令SHR&quot;">​</a></h2><p><code>SHR OPD，1 或 SHR OPD，CL</code></p><ul><li>功能：将(OPD)向右移动CL规定的次数，最高位补入相应个数的0，CF的内容为最后移出位的值</li><li>用SHR指令可以实现对无符号数除以2^n^的运 算(n为移位次数) 、但需注意余数1(CF)</li></ul><h2 id="算术右移指令sar" tabindex="-1">算术右移指令SAR <a class="header-anchor" href="#算术右移指令sar" aria-label="Permalink to &quot;算术右移指令SAR&quot;">​</a></h2><p><code>SAR OPD，1 或 SAR OPD，CL</code></p><ul><li>功能：将(OPD)向右移动CL指定的次数且最高位保持不变；CF的内容为最后移出位的值。</li><li>用SAR指令可以实现对有符号数除以2^n^的运 算(n为移位次数)、但需注意余数1(CF)</li></ul><h2 id="循环移位指令" tabindex="-1">循环移位指令 <a class="header-anchor" href="#循环移位指令" aria-label="Permalink to &quot;循环移位指令&quot;">​</a></h2><blockquote><ul><li>循环左移指令 ROL OPD，1/CL</li><li>循环右移指令 ROR OPD，1/CL</li><li>带进位位循环左移指令 RCL OPD，1/CL</li><li>带进位位循环右移指令 RCR OPD，1/CL</li><li>前两条指令未把标志位CF包括在循环的环中， 而后两条指令把CF包括在循环中，作为整个循环的一部分。</li></ul></blockquote><h3 id="eg1-将一个2位的压缩bcd码转换成二进制数。" tabindex="-1">eg1:将一个2位的压缩BCD码转换成二进制数。 <a class="header-anchor" href="#eg1-将一个2位的压缩bcd码转换成二进制数。" aria-label="Permalink to &quot;eg1:将一个2位的压缩BCD码转换成二进制数。&quot;">​</a></h3><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>DATAS SEGMENT</span></span>
<span class="line"><span>	BCD DB 01011001B ;59H</span></span>
<span class="line"><span>	BIN DB ? ;转换为59D</span></span>
<span class="line"><span>DATAS ENDS</span></span>
<span class="line"><span></span></span>
<span class="line"><span>CODES SEGMENT</span></span>
<span class="line"><span>ASSUME CS:CODES,DS:DATAS</span></span>
<span class="line"><span>	START:</span></span>
<span class="line"><span>	MOV AL,BCD</span></span>
<span class="line"><span>	MOV BL,AL</span></span>
<span class="line"><span>	AND BL,0FH ;BL存放低4位</span></span>
<span class="line"><span>	</span></span>
<span class="line"><span>	MOV CL,4</span></span>
<span class="line"><span>	SHR AL,CL ;AL现存放高4位</span></span>
<span class="line"><span>	MOV BH,10D</span></span>
<span class="line"><span>	MUL BH</span></span>
<span class="line"><span>	ADD AL,BL</span></span>
<span class="line"><span>	MOV BIN,AL  ;两位BCD码表示的最大数小于（2^8－1）</span></span>
<span class="line"><span>CODES ENDS</span></span>
<span class="line"><span>END START</span></span></code></pre></div><h3 id="eg2-把一组寄存器cx-bx-ax中的一个48位二进制-数整体逻辑左移一位" tabindex="-1">eg2:把一组寄存器CX:BX:AX中的一个48位二进制 数整体逻辑左移一位 <a class="header-anchor" href="#eg2-把一组寄存器cx-bx-ax中的一个48位二进制-数整体逻辑左移一位" aria-label="Permalink to &quot;eg2:把一组寄存器CX:BX:AX中的一个48位二进制 数整体逻辑左移一位&quot;">​</a></h3><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SHL AX,1</span></span>
<span class="line"><span>RCL BX,1</span></span>
<span class="line"><span>RCL CX,1</span></span></code></pre></div><p>如果要求左移4位，如何实现？</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SHL AX, 1      ; AX循环左移1位</span></span>
<span class="line"><span>RCL BX, 1      ; BX循环左移1位</span></span>
<span class="line"><span>RCL CX, 1      ; CX循环左移1位</span></span>
<span class="line"><span></span></span>
<span class="line"><span>SHL AX, 1      ; AX循环左移1位</span></span>
<span class="line"><span>RCL BX, 1      ; BX循环左移1位</span></span>
<span class="line"><span>RCL CX, 1      ; CX循环左移1位</span></span>
<span class="line"><span></span></span>
<span class="line"><span>SHL AX, 1      ; AX循环左移1位</span></span>
<span class="line"><span>RCL BX, 1      ; BX循环左移1位</span></span>
<span class="line"><span>RCL CX, 1      ; CX循环左移1位</span></span>
<span class="line"><span></span></span>
<span class="line"><span>SHL AX, 1      ; AX循环左移1位</span></span>
<span class="line"><span>RCL BX, 1      ; BX循环左移1位</span></span>
<span class="line"><span>RCL CX, 1      ; CX循环左移1位</span></span></code></pre></div><p>如果改为循环左移一位，程序应该如何修改？</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>PUSH AX</span></span>
<span class="line"><span>RCL AX</span></span>
<span class="line"><span>RCL BX</span></span>
<span class="line"><span>RCL CX</span></span>
<span class="line"><span>POP AX</span></span>
<span class="line"><span>PCL AX</span></span></code></pre></div><h1 id="转移和调用指令" tabindex="-1">转移和调用指令 <a class="header-anchor" href="#转移和调用指令" aria-label="Permalink to &quot;转移和调用指令&quot;">​</a></h1><h2 id="分类" tabindex="-1">分类 <a class="header-anchor" href="#分类" aria-label="Permalink to &quot;分类&quot;">​</a></h2><ol><li><p>按转移的范围：根据转移指令与目标指令 是否属于同一个逻辑段</p><ul><li>段内、近程(NEAR)转移：仅仅修改IP(16位) <ul><li>其中，短(SHORT ) 转移：加上一个8位的相对位 移量以修改16位IP；</li></ul></li><li>段间、远程(FAR)转移：同时修改IP和CS</li></ul></li><li><p>按获取目标指令地址的方法</p><ul><li>直接：转移指令使用标号或过程名作为转移的目标 <ul><li>标号：是定义在目标指令前面的一个符号名，代表目标指 令所在存储单元的逻辑地址。注意：标号必须区分类型： NEAR / FAR。</li></ul></li><li>间接：目标地址事先位于寄存器或者某几个存储单 元，当CPU执行JMP等转移指令时, 将寄存器或内存 单元内的有效地址写入IP或EIP, 从而实现转移。</li></ul></li><li><p>按是否存在转移条件</p><ul><li>无条件转移和条件转移指令</li></ul></li></ol><h2 id="无条件转移指令jmp" tabindex="-1">无条件转移指令JMP <a class="header-anchor" href="#无条件转移指令jmp" aria-label="Permalink to &quot;无条件转移指令JMP&quot;">​</a></h2><ul><li><p>无条件转移指令的执行结果不影响标志位</p></li><li><p>段内、近转移</p><ul><li><code>JMP [ NEAR PTR ] 标号</code></li><li>目标指令地址相对于当前转 移指令地址的相对位移量介于范围：-32768~ ＋32767 (16位相对位移量) ，转移范围基本上 可以覆盖整个逻辑段；</li></ul></li><li><p>段内、短转移</p><ul><li><code>JMP SHORT 标号</code></li><li>目标指令地址相对于当前转移指令地址的相对位移量介于范围： 128~+127 (8位相对位移量)</li><li>短转移指令的优点：长度比段内、短转移指令节省一个字节。</li></ul></li><li><p>段内、间接转移</p><ul><li><code>JMP [ NEAR PTR ] 寄存器操作数</code></li><li><code>JMP [ NEAR PTR ] 存储器操作数</code></li><li>寄存器、内存单元存放的是用于修改 IP的偏移地址EA！</li><li>所谓“间接”，是指当CPU执行指令时，将寄存器或内存单元内的有效地址写入IP或EIP， 从而实现转移</li></ul></li><li><p>段间、直接转移</p><ul><li><code>JMP [ FAR PTR ] 标号</code></li><li>指令中直接给出转向的4字节的偏移量和段基址, 执行时将偏移量送IP、段基址送CS，即可 实现段间直接转移。</li><li>一个模块中不同的指令段之间或者在模 块化程序设计中，从一个模块转移到另一个 模块：必须执行段间转移指令。</li><li>现代操作系统允许多道程序并发执行、且每道程 序可能包含多个代码段(最多2^14^个段)</li></ul></li><li><p>段间、间接转移</p><ul><li><code>JMP [ FAR PTR ] 存储器操作数</code></li><li>(IP) ←目标指令所在存储单元的EA</li><li>(CS)←目标指令所在存储单元的段地址(EA+2)</li></ul></li></ul><h3 id="eg1" tabindex="-1">eg1 <a class="header-anchor" href="#eg1" aria-label="Permalink to &quot;eg1&quot;">​</a></h3><p>已知：(DS)＝2000H，(BX)＝0300H，(IP)＝0100H， (20300H)＝12H，(20301H)＝34H。</p><ol><li><p><code>JMP BX</code> ;执行后(IP)＝？</p><ul><li>(IP)＝(BX)＝ 0300H</li></ul></li><li><p><code>JMP WORD PTR [BX]</code></p><ul><li><p>指令执行时，首先根据存储器操作数寻址方式得到目标指令所在存储单元的地址： 10H ×(DS)＋(BX)＝ 20300H</p></li><li><p>再从该单元开始连续读取2个存储单元的内容，从而 获得转移地址：EA＝(20300H)＝3412H</p></li><li><p>(IP)＝EA＝3412H，下一次便执行CS:3412H 处的指令，实现了段内间接转移</p></li></ul></li></ol><h3 id="eg2" tabindex="-1">eg2 <a class="header-anchor" href="#eg2" aria-label="Permalink to &quot;eg2&quot;">​</a></h3><p>已知：(DS)＝2000H，(BX)＝0300H，(IP)＝ 0100H，(20300H)＝ 0，(20301H)＝ 05H，(20302H) ＝10H，(20303H)＝60H。</p><ol><li><code>JMP DWORD PTR [BX]</code><ul><li>式中DWORD PTR [BX]表示BX指向一个双 字变量。指令执行时，先按照与操作数有关的寻址 方式得到存放转移地址的内存单元：10H×(DS)＋ (BX)＝ 20300H。</li><li>再把该单元中的低字送给IP，高字送给CS，即 0500H →IP，6010H→CS,下一次便执行6010:0500H 处的指令，实现了段间间接转移。</li></ul></li></ol><h2 id="条件转移指令" tabindex="-1">条件转移指令 <a class="header-anchor" href="#条件转移指令" aria-label="Permalink to &quot;条件转移指令&quot;">​</a></h2><p><code>操作码助记符 转移地址标号</code></p><ul><li>根据上一条指令对标志寄存器中状态 标志位的影响来决定程序执行的流程</li><li>若满足条件时：跳转到目标标号处的指令执行；否则，顺序执行转移指令后面的下一条指令。</li></ul><h3 id="根据-单个状态标志" tabindex="-1">根据：单个状态标志 <a class="header-anchor" href="#根据-单个状态标志" aria-label="Permalink to &quot;根据：单个状态标志&quot;">​</a></h3><table tabindex="0"><thead><tr><th>标志</th><th>为1时转移</th><th>为0时转移</th></tr></thead><tbody><tr><td>ZF</td><td>JZ(JE) 结果为0/相等转移</td><td>JNZ(JNE)</td></tr><tr><td>SF</td><td>JS 负数转移</td><td>JNS</td></tr><tr><td>OF</td><td>JO 溢出转移</td><td>JNO</td></tr><tr><td>PF</td><td>JP(JPE) 偶转移</td><td>JNP(JPO)</td></tr><tr><td>CF</td><td>JC(JB(JNAE)) 有进位转移</td><td>JNC(JNB/JAE)</td></tr></tbody></table><h3 id="根据-无符号数的大小" tabindex="-1">根据：无符号数的大小 <a class="header-anchor" href="#根据-无符号数的大小" aria-label="Permalink to &quot;根据：无符号数的大小&quot;">​</a></h3><p>记忆方法: A:大于， B:小于， E:等于</p><p><img src="https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241221162657513.png" alt="image-20241221162657513"></p><h3 id="根据-有符号数的大小" tabindex="-1">根据：有符号数的大小 <a class="header-anchor" href="#根据-有符号数的大小" aria-label="Permalink to &quot;根据：有符号数的大小&quot;">​</a></h3><p><img src="https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241221164158727.png" alt="image-20241221164158727"></p><h3 id="eg1-1" tabindex="-1">eg1 <a class="header-anchor" href="#eg1-1" aria-label="Permalink to &quot;eg1&quot;">​</a></h3><blockquote><p>设有10个字节属性的数据存放在以 2000H单元为首地址的数据缓冲器中,试编程实现找出其中的最大数,并存入2100H单元。</p></blockquote><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>MOV BX,2000H ;缓冲区首地址</span></span>
<span class="line"><span>MOV AL,[BX]  ;10个数据：假设第一个数即为最大</span></span>
<span class="line"><span>MOV CX,9</span></span>
<span class="line"><span>LAB:</span></span>
<span class="line"><span>	INC BX</span></span>
<span class="line"><span>	CMP AL,[BX]</span></span>
<span class="line"><span>	JAE LABEL</span></span>
<span class="line"><span>	MOV AL,[BX]</span></span>
<span class="line"><span>LABEL:</span></span>
<span class="line"><span>	DEC CX</span></span>
<span class="line"><span>	JNZ LAB</span></span>
<span class="line"><span>	</span></span>
<span class="line"><span>	MOV BX,2100H</span></span>
<span class="line"><span>	MOV [BX],AL</span></span></code></pre></div><p>循环思路：</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>MOV BX,2000H ;缓冲区首地址</span></span>
<span class="line"><span>MOV AL,[BX]  ;10个数据：假设第一个数即为最大</span></span>
<span class="line"><span>MOV CX,9</span></span>
<span class="line"><span>LAB:</span></span>
<span class="line"><span>	INC BX</span></span>
<span class="line"><span>	CMP AL,[BX]</span></span>
<span class="line"><span>	JBE NEXT</span></span>
<span class="line"><span>	MOV AL,[BX] </span></span>
<span class="line"><span>NEXT:</span></span>
<span class="line"><span>	LOOP LAB</span></span>
<span class="line"><span>	</span></span>
<span class="line"><span>	MOV BX,2100H</span></span>
<span class="line"><span>	MOV [BX],AL</span></span></code></pre></div><h3 id="eg2-1" tabindex="-1">eg2 <a class="header-anchor" href="#eg2-1" aria-label="Permalink to &quot;eg2&quot;">​</a></h3><blockquote><p>假设X为某值且存放在寄存器AL中，求出函数值f(x)并存放在AH中</p><p>f(x) = 0,x=0</p><p>f(x)=1,x&gt;0</p><p>f(x)=-1,x&lt;0</p></blockquote><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CMP AL,0</span></span>
<span class="line"><span>JGE BIG</span></span>
<span class="line"><span>MOV AL,0FFH</span></span>
<span class="line"><span>JMP DOWN</span></span>
<span class="line"><span>BIG:</span></span>
<span class="line"><span>	JE DOWN</span></span>
<span class="line"><span>	MOV AL,1</span></span>
<span class="line"><span>DOWN:</span></span>
<span class="line"><span>	MOV AH,AL</span></span></code></pre></div><h2 id="循环类指令" tabindex="-1">循环类指令 <a class="header-anchor" href="#循环类指令" aria-label="Permalink to &quot;循环类指令&quot;">​</a></h2><h3 id="循环指令loop" tabindex="-1">循环指令LOOP <a class="header-anchor" href="#循环指令loop" aria-label="Permalink to &quot;循环指令LOOP&quot;">​</a></h3><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>MOV   CX，100         ;100次输送CX </span></span>
<span class="line"><span>START：</span></span>
<span class="line"><span></span></span>
<span class="line"><span> ...  ...       ;要执行100次的程序段</span></span>
<span class="line"><span></span></span>
<span class="line"><span>LOOP  START  ;CX≠0，转START执行</span></span>
<span class="line"><span></span></span>
<span class="line"><span> ...  ...       ;CX=0，继续顺序执行</span></span></code></pre></div><p>功能上，使用LOOP指令可用两条指令代替： •</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>DEC  CX </span></span>
<span class="line"><span>JNE  SHORT 标号</span></span></code></pre></div><h3 id="相等-为零循环指令loope" tabindex="-1">相等/为零循环指令LOOPE <a class="header-anchor" href="#相等-为零循环指令loope" aria-label="Permalink to &quot;相等/为零循环指令LOOPE&quot;">​</a></h3><p><code>LOOPE 标号，或 LOOPZ 标号</code></p><ul><li><p>功能：</p><ul><li><p>(1)(CX)－1 → CX；</p></li><li><p>(2)如果(CX) ≠0且ZF=1，则程序转移(循环)； 否则，顺序执行</p></li></ul></li><li><p>应用场合</p><ul><li>比较两个字符串/数组/文件是否相同(出现第 一个不相等的数据则终止循环)。</li></ul></li></ul><h3 id="不相等-不为零循环指令loopne" tabindex="-1">不相等/不为零循环指令LOOPNE <a class="header-anchor" href="#不相等-不为零循环指令loopne" aria-label="Permalink to &quot;不相等/不为零循环指令LOOPNE&quot;">​</a></h3><p><code>LOOPNE 标号，或 LOOPNZ 标号</code></p><ul><li><p>功能：</p><ul><li><p>(1)(CX)－1 → CX；</p></li><li><p>(2)如果(CX) ≠0且ZF=0，则程序转移(循环)； 否则，顺序执行</p></li></ul></li><li><p>应用场合</p><ul><li>在一片数据区域(一个字符串/数组/文件)中， 寻找第一个等于给定关键字(例如0)的数据</li></ul></li></ul><h4 id="eg1-2" tabindex="-1">eg1 <a class="header-anchor" href="#eg1-2" aria-label="Permalink to &quot;eg1&quot;">​</a></h4><p>在指定的字节型数据的存储区中，查询 第一个等于关键字X的数据元素所在的地址。</p><ul><li>设存储区开始单元的偏移地址在BX中，最后单元的偏移地址在DI中；</li><li>若找到关键字数据，则将其偏移地址存放在 BX中；</li><li>若没有找到，则循环结束时必有BX与DI相等， 表示已搜索至最后单元。</li></ul><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SUB DI,BX</span></span>
<span class="line"><span>MOV CX,DI</span></span>
<span class="line"><span>NEXT:</span></span>
<span class="line"><span>	CMP BYTE PTR [BX],&#39;X&#39;</span></span>
<span class="line"><span>	INC BX</span></span>
<span class="line"><span>	LOOPNZ NEXT</span></span>
<span class="line"><span>	JZ FOUND ;找到</span></span>
<span class="line"><span>	.....；没找到</span></span>
<span class="line"><span>FOUND:  ;找到：(BX)即为关键字</span></span>
<span class="line"><span>	......</span></span></code></pre></div><h4 id="eg2-2" tabindex="-1">eg2 <a class="header-anchor" href="#eg2-2" aria-label="Permalink to &quot;eg2&quot;">​</a></h4><p>编程实现：找出以ARRAY为 首地址的100个字型数组中的第一个非0 项（不等于关键字0），送AX中</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>DS： ARRAY DW 0，0，0，1010H，··· ;（100个数）</span></span>
<span class="line"><span>CS：对DS初始化</span></span>
<span class="line"><span>MOV    CX，100</span></span>
<span class="line"><span>LEA BX，ARRAY</span></span>
<span class="line"><span>MOV SI，0FFFEH       ;－2，修正下列的INC</span></span>
<span class="line"><span>ZERO： </span></span>
<span class="line"><span>	INC SI</span></span>
<span class="line"><span>	INC SI</span></span>
<span class="line"><span>	CMP  WORD PTR [BX+SI]，0  ；关键字是0</span></span>
<span class="line"><span> 	LOOPZ ZERO         </span></span>
<span class="line"><span>MOV AX，[BX+SI]</span></span></code></pre></div><h3 id="cx为零转移指令jcxz" tabindex="-1">CX为零转移指令JCXZ <a class="header-anchor" href="#cx为零转移指令jcxz" aria-label="Permalink to &quot;CX为零转移指令JCXZ&quot;">​</a></h3><p><code>JCXZ 标号</code></p><p>功能：</p><ul><li>如果(CX) ＝0 则程序转移(循环)；否 则，顺序执行</li></ul><h1 id="子程序调用与返回指令" tabindex="-1">子程序调用与返回指令 <a class="header-anchor" href="#子程序调用与返回指令" aria-label="Permalink to &quot;子程序调用与返回指令&quot;">​</a></h1><p>call</p><p>子程序即过程</p><h1 id="中断调用及返回" tabindex="-1">中断调用及返回 <a class="header-anchor" href="#中断调用及返回" aria-label="Permalink to &quot;中断调用及返回&quot;">​</a></h1><ol><li><code>INT n </code><ul><li>INT n指令类似于CALL指令，但是每次压栈 时必须同时保护3个寄存器，入栈顺序是 FLAGS、CS、IP。</li></ul></li><li>中断返回指令<code>IRET</code><ul><li>该指令为中断服务程序的返回指令。 类似于RET，CPU总是依次从栈顶弹出6个字 节依次送入IP、CS、FLAGS寄存器(按中断 调用时的逆序恢复断点) ，从而返回主程序的 断点</li></ul></li></ol>`,93),i=[e];function t(c,o,d,h,u,r){return n(),s("div",null,i)}const C=a(p,[["render",t]]);export{g as __pageData,C as default};
