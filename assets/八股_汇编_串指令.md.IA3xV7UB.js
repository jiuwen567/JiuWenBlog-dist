import{_ as a,c as s,o as n,a6 as l}from"./chunks/framework.DkFL-jqo.js";const D=JSON.parse('{"title":"串指令的通用规则","description":"","frontmatter":{},"headers":[],"relativePath":"八股/汇编/串指令.md","filePath":"八股/汇编/串指令.md"}'),p={name:"八股/汇编/串指令.md"},i=l(`<h1 id="串指令的通用规则" tabindex="-1">串指令的通用规则 <a class="header-anchor" href="#串指令的通用规则" aria-label="Permalink to &quot;串指令的通用规则&quot;">​</a></h1><ol><li><p>串操作指令一定会涉及存储器操作数：</p><ul><li>默认源串由DS：[SI]指出(DS可用段前缀指令改变)；</li><li>默认目的串由ES：[DI]指出(不允许使用段超越前缀)。</li></ul></li><li><p>如果涉及寄存器操作数：只能位于累加器 AL/AX/EAX中。</p></li><li><p>任何一条串操作指令执行结束时，SI/DI 会自动增/减：1或者2或者4！！！</p></li><li><p>增加或者减少由DF标志位决定：若DF=0则加， 若DF=1则减</p></li><li><p>增减的数值：由串操作指令本身指定的数据 长度(字节数)决定</p></li><li><p>常常使用重复前缀</p><ul><li><code>REP ； REPE／REPZ； REPNE／REPNZ。</code></li><li>重复前缀的功能：与LOOP指令类似，重复 操作的次数由CX决定，执行时需判断(CX)是 否非0</li><li>使用重复前缀时，应该把需要处理的数据个数(不是字节数！)预先存放在CX中， 数据可以是字节型、字型或者双字型</li><li>REPE／REPZ(相等重复前缀)：当(CX≠0)且 ZF＝1时，串指令重复执行；一旦条件不满足，重复就停止。 <ul><li>与LOOPE/LOOPZ 类似、REPE／REPZ常常用于比较两个字符串/数组/文件是否相同</li></ul></li><li>REPNE/REPNZ(不等重复前缀)：当(CX≠0) 且ZF＝0时，串指令重复执行。 <ul><li>与LOOPNE/LOOPNZ 类似、REPNE／ REPNZ常常用于从一个字符串或数组或文件 中搜索是否存在一个数据等于给定的关键字</li></ul></li></ul></li></ol><h1 id="串传送指令movs" tabindex="-1">串传送指令MOVS <a class="header-anchor" href="#串传送指令movs" aria-label="Permalink to &quot;串传送指令MOVS&quot;">​</a></h1><ul><li><p>MOVSB ；字节传送</p></li><li><p>MOVSW ；字传送</p></li><li><p>MOVSD ；双字传送</p></li><li><p>显式<code>MOVS OPRD1，OPRD2</code></p></li><li><p>功能：将以DS：[ SI ]为指针的源串中存储单元中的 一个字节(或字或双字) 型的数据传送至以ES：[ DI ] 寻址的目的地址中去，并自动修改指针SI、DI ，使 之指向下一个字节(或字或双字)存储单元。</p></li><li><p>(DS：[SI])→ES：[DI]。</p></li><li><p>当DF=0时，(SI)和(DI)增量。当DF=1时，(SI)和(DI)减量。</p></li><li><p>该指令可以使用前缀REP。功能：当(CX)≠0 时，执行一次串指令，(CX)－1 → CX ，直到 (CX)=0时循环结束</p></li></ul><h2 id="eg-数据块传送" tabindex="-1">eg-数据块传送 <a class="header-anchor" href="#eg-数据块传送" aria-label="Permalink to &quot;eg-数据块传送&quot;">​</a></h2><p>将数据段(由DS寻址段基址)中SRC单元开始 的100个字节，依次传送到：附加段(由ES寻址段基址)中DST开始的内存区域中。</p><p>设数据段： SRC DB ×，…，× • ;100个字节型数据 • 设附加段： DST DB 100 DUP(?)</p><ol><li><p>用MOV指令编程</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>LEA DI,SRC</span></span>
<span class="line"><span>LEA SI,DST</span></span>
<span class="line"><span>MOV CX,100</span></span>
<span class="line"><span>NEXT:</span></span>
<span class="line"><span>	MOV AL,[SI]</span></span>
<span class="line"><span>	MOV ES:[DI],AL</span></span>
<span class="line"><span>	INC SI</span></span>
<span class="line"><span>	INC DI</span></span>
<span class="line"><span>	LOOP NEXT</span></span></code></pre></div></li><li><p>用MOVSB指令编程</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>LEA DI,SRC</span></span>
<span class="line"><span>LEA SI,DST</span></span>
<span class="line"><span>MOV CX,100</span></span>
<span class="line"><span>LAST:</span></span>
<span class="line"><span>	MOVSB ;串指令：SI、DI自动变。</span></span>
<span class="line"><span>	LOOP LAST</span></span></code></pre></div></li><li><p>用REP MOVSB指令编程</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>LEA DI,SRC</span></span>
<span class="line"><span>LEA SI,DST</span></span>
<span class="line"><span>MOV CX,100</span></span>
<span class="line"><span>CLD ;使DF=0</span></span>
<span class="line"><span>REP MOVSB</span></span></code></pre></div></li><li><p>用REP MOVSD指令编程</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>LEA DI,SRC</span></span>
<span class="line"><span>LEA SI,DST</span></span>
<span class="line"><span>MOV CX,25  ;充分利用字长，减少了：循环次数</span></span>
<span class="line"><span>CLD ;使DF=0</span></span>
<span class="line"><span>REP MOVSD</span></span></code></pre></div><h1 id="串装入指令" tabindex="-1">串装入指令 <a class="header-anchor" href="#串装入指令" aria-label="Permalink to &quot;串装入指令&quot;">​</a></h1></li></ol><ul><li>LODSB ；DS:[SI]中的一个字节送AL</li><li>LODSW ；DS:[SI]中的一个字送AX</li><li>LODSD ；DS:[SI]中的一个双字送EAX</li><li>显式格式：LODS SRC</li><li>将通过DS：[SI]寻址的源串中一个字节(或字或双字) 型数据装入到寄存器AL/AX/EAX中，且根据DF的值，自动修改SI的值，以指向下一个要装入的字节或字或双字。</li><li>字节操作：(DS:[SI])→AL 字操作：(DS:[SI])→AX。</li><li>修改指针SI，使它指向串中的下一个元素。当DF=0时， (SI)增量。当DF=1时，(SI)减量。(注意：此时DI不变。)</li><li>串装入指令如果带前缀REP无意义</li></ul><h1 id="串存储指令" tabindex="-1">串存储指令 <a class="header-anchor" href="#串存储指令" aria-label="Permalink to &quot;串存储指令&quot;">​</a></h1><ul><li>STOSB ；把AL→ ES:[ DI]的1个单元</li><li>STOSW ；把AX→ ES:[ DI]的2个单元</li><li>STOSD ；把EAX→ ES:[ DI]的4个单元</li><li>显式格式：STOS DST</li><li>功能：将寄存器AL/AX/EAX中的一个字节(或字或 双字)数据存储到由ES：[DI]寻址的附加段中去，并且根据DF的值来修改DI的值，以指向下一个要装入 的字节或字或双字数据。</li><li>字节操作：(AL)→ ES：[DI]，字操作：(AX)→ ES：[DI]；</li><li>修改指针DI，使之指向串中的下一个元素。当 DF=0时，(DI)增量。当DF=1时，(DI)减量。</li><li>该指令可以带前缀REP。重复前缀的格式<code>REP STOSB/STOSW/STOSD</code></li><li>功能是: <ul><li>对一片连续的存储空间赋予一个相同的数值 (来自于AL/AX/EAX)；</li><li>通常是对一片连续的存储空间执行清0操作。</li></ul></li></ul><h2 id="eg-用lodsb-stosb指令编程" tabindex="-1">eg-[用LODSB，STOSB指令编程] <a class="header-anchor" href="#eg-用lodsb-stosb指令编程" aria-label="Permalink to &quot;eg-[用LODSB，STOSB指令编程]&quot;">​</a></h2><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>LEA    SI，SRC</span></span>
<span class="line"><span>LEA    DI，DST</span></span>
<span class="line"><span>MOV    CX，100</span></span>
<span class="line"><span>CLD ;使DF=0</span></span>
<span class="line"><span>LAST：LODSB</span></span>
<span class="line"><span>	 STOSB</span></span>
<span class="line"><span>LOOP LAST</span></span></code></pre></div><h1 id="串比较指令cmp" tabindex="-1">串比较指令CMP <a class="header-anchor" href="#串比较指令cmp" aria-label="Permalink to &quot;串比较指令CMP&quot;">​</a></h1><ul><li>CMPSB ；字节比较</li><li>CMPSW ；字比较</li><li>CMPSD ；双字比较</li><li>CMPS OPRD1源，OPRD2目的；</li><li>(DS：[SI])－(ES：[DI])。</li><li>修改串指针，使之指向串中的下一个元素。 当DF=0时，(SI)和(DI)增量。当DF=1时，(SI) 和(DI)减量。</li><li>串比较命令是将数据段DS：[SI]指针 指出的一个字节或字或双字型数据与附加段 ES：[DI]指出的字节或字或双字型数据进行 比较(相减)，根据比较结果设置标志位寄存器， 而结果不保存。常用于内存区之间的数据、 字符等的比较。</li><li>CMP串比较指令常与REPE/Z配合，用 来判断两个数组/字符串/文件所包含的元素是 否完全相同</li></ul><h2 id="eg" tabindex="-1">eg <a class="header-anchor" href="#eg" aria-label="Permalink to &quot;eg&quot;">​</a></h2><blockquote><p>设数据区有两个字节串，串1的长度为5，串2 的长度为10。</p><p>请判断：若串2的最后5个字符和串1相同，则 置FLAG单元为‘Y’，否则置为‘N’。</p></blockquote><p>解法1：地址正向变化 ；即：首先处理低地址，SI/DI自动加；</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>设数据段STRING1 DB x ，…，x;串1长度＝5</span></span>
<span class="line"><span>附加段 STRING2 DB x ，…，x;串2长度＝10</span></span>
<span class="line"><span> FLAG  DB  ‘Y’</span></span>
<span class="line"><span>对DS，ES初始化</span></span>
<span class="line"><span></span></span>
<span class="line"><span>LEA    SI，STRING1</span></span>
<span class="line"><span> LEA    DI，STRING2+5</span></span>
<span class="line"><span> </span></span>
<span class="line"><span> MOV    CX，5</span></span>
<span class="line"><span> CLD ;DF=0</span></span>
<span class="line"><span> REPE  CMPSB</span></span>
<span class="line"><span> JZ    EXIT </span></span>
<span class="line"><span> MOV   FLAG，’N’</span></span>
<span class="line"><span> EXIT ;返回DOS操作系统</span></span></code></pre></div><p>解法2：地址逆向变化</p><p>首先处理高地址，SI/DI自动减；</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>数据段STRING1 DB x ，…，x;串1长度＝5</span></span>
<span class="line"><span>附加段 STRING2 DB x ，…，x;串2长度＝10</span></span>
<span class="line"><span> FLAG  DB  ‘Y’</span></span>
<span class="line"><span> 对DS，ES初始化</span></span>
<span class="line"><span>LEA    SI，STRING1+4</span></span>
<span class="line"><span>LEA    DI，STRING2+9</span></span>
<span class="line"><span>MOV    CX，5</span></span>
<span class="line"><span>STD  ;DF=1</span></span>
<span class="line"><span>REPE  CMPSB</span></span>
<span class="line"><span>JZ    EXIT         ;ZF=1，说明两个字符串完全相同、无需修改</span></span>
<span class="line"><span>MOV   FLAG，’N’</span></span>
<span class="line"><span>EXIT 回DOS操作系统</span></span></code></pre></div><h1 id="串搜索指令scas" tabindex="-1">串搜索指令SCAS <a class="header-anchor" href="#串搜索指令scas" aria-label="Permalink to &quot;串搜索指令SCAS&quot;">​</a></h1><ul><li>SCASB ；字节比较</li><li>SCASW ；字比较</li><li>SCASD ；双字比较</li><li>显式格式：SCAS DST</li><li>功能：串搜索指令将AL/AX/EAX中一个字节或字或 双字型数据的值减去在附加段ES中由ES：[DI]寻址 的目标串的字节或字或双字数据，根据相减结果设 置标志位，结果不保存；修改DI指针，修改情况如 上所述，由DF的值决定。</li><li>SCAS串搜索指令常与REPNZ配合，用 来查找一片数据区域(一个数组/字符串/文件) 中是否存在指定的关键字(放在AL/AX/EAX 中)。</li></ul><h2 id="eg-1" tabindex="-1">eg <a class="header-anchor" href="#eg-1" aria-label="Permalink to &quot;eg&quot;">​</a></h2><blockquote><p>在附加段中有一个字符串，存放在以符号地址MESS2开 始的区域中，长度为17，要求在该字符串中搜索空格符(ASCII码为20H)。</p></blockquote><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>...</span></span>
<span class="line"><span>CLD</span></span>
<span class="line"><span>LEA   DI，MESS2   ;装入目的串偏移地址</span></span>
<span class="line"><span>MOV  AL，20H ;装入关键字</span></span>
<span class="line"><span>MOV  CX，17        </span></span>
<span class="line"><span>REPNE SCASB</span></span>
<span class="line"><span>...</span></span></code></pre></div><h1 id="处理机控制指令" tabindex="-1">处理机控制指令 <a class="header-anchor" href="#处理机控制指令" aria-label="Permalink to &quot;处理机控制指令&quot;">​</a></h1><blockquote><p>80x86处理器控制指令用于修改标志位寄存器， 或与外部设备同步，以及用来控制处理器与 协处理器之间的相互作用</p></blockquote><h2 id="标志位操作指令" tabindex="-1">标志位操作指令 <a class="header-anchor" href="#标志位操作指令" aria-label="Permalink to &quot;标志位操作指令&quot;">​</a></h2><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>STC       ;使CF=1      </span></span>
<span class="line"><span>CLC       ;使CF=0     </span></span>
<span class="line"><span>CMC       ;使CF取反   </span></span>
<span class="line"><span>STD       ;使DF=1    </span></span>
<span class="line"><span>CLD       ;使DF=0   </span></span>
<span class="line"><span>STI       ;使IF=1    </span></span>
<span class="line"><span>CLI       ;使IF=0</span></span></code></pre></div><h2 id="其它处理机状态的控制指令" tabindex="-1">其它处理机状态的控制指令 <a class="header-anchor" href="#其它处理机状态的控制指令" aria-label="Permalink to &quot;其它处理机状态的控制指令&quot;">​</a></h2><blockquote><p>这组指令可以控制处理机状态，它们均不影 响标志，有时称为外部同步指令</p></blockquote><p><img src="https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241224152205499.png" alt="image-20241224152205499"></p><h1 id="i-o指令" tabindex="-1">I/O指令 <a class="header-anchor" href="#i-o指令" aria-label="Permalink to &quot;I/O指令&quot;">​</a></h1><blockquote><p>接口电路通常包含一组寄存器/存储电路，这 些与CPU交换信息的存储硬件称I/O端口寄存 器，简称端口。</p><p>对于不同的端口：X86系统采用独立编址，其 他系统有的采用统一编址</p></blockquote><h2 id="in输入指令1" tabindex="-1">IN输入指令1 <a class="header-anchor" href="#in输入指令1" aria-label="Permalink to &quot;IN输入指令1&quot;">​</a></h2><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>IN AL,PORT    ;字节输入  </span></span>
<span class="line"><span>IN AX,PORT   ;字输入</span></span>
<span class="line"><span>IN EAX,PORT  ;双字输入</span></span></code></pre></div><p>PORT此时为8位端口号，取值范围00~FFH。</p><p>执行的操作：从外设端口地址为PORT的端口中将 数据输入到AL 或AX，EAX中</p><ul><li>AL &lt;–(PORT)</li><li>AX &lt;–(PORT+1),(PORT)</li><li>EAX &lt;–(PORT+3), ( PORT+2), ( PORT+1) ,( PORT）</li></ul><p><img src="https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241224152748988.png" alt="image-20241224152748988"></p><h2 id="in输入指令2" tabindex="-1">IN输入指令2 <a class="header-anchor" href="#in输入指令2" aria-label="Permalink to &quot;IN输入指令2&quot;">​</a></h2><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>IN AL,DX    ;字节输入  </span></span>
<span class="line"><span>IN AX,DX   ;字输入</span></span>
<span class="line"><span>IN EAX,DX  ;双字输入</span></span></code></pre></div><p>DX寄存器的内容是16位端口号（0000~FFFFH）。</p><p>执行的操作：从外设端口地址为(DX)的端口中将一字节或字 数据输入到AL 或AX，EAX中。</p><ul><li>AL &lt;–(DX)</li><li>AX &lt;–(DX+1),(DX)</li><li>EAX &lt;–(DX+3), ( DX+2), ( DX+1) ,( DX）</li></ul><p><img src="https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241224153037037.png" alt="image-20241224153037037"></p><h2 id="out输出指令" tabindex="-1">Out输出指令 <a class="header-anchor" href="#out输出指令" aria-label="Permalink to &quot;Out输出指令&quot;">​</a></h2><p>同in</p><p>执行的操作：将AL/ AX/ EAX中的数据输出到外设端口中。</p><h2 id="insb-insw-insd-从端口输入字符串" tabindex="-1">INSB/INSW/INSD 从端口输入字符串 <a class="header-anchor" href="#insb-insw-insd-从端口输入字符串" aria-label="Permalink to &quot;INSB/INSW/INSD 从端口输入字符串&quot;">​</a></h2><p>从DX指定端口输入一个字节,字或双字元 素传送到ES:[DI]所指定的存储单元,同时自动修改目的指针</p><h2 id="outsb-outsw-outsd-从端口输入字符串" tabindex="-1">OUTSB/OUTSW/OUTSD 从端口输入字符串 <a class="header-anchor" href="#outsb-outsw-outsd-从端口输入字符串" aria-label="Permalink to &quot;OUTSB/OUTSW/OUTSD 从端口输入字符串&quot;">​</a></h2><p>把DS:[SI]所指定的存储单元一个字节, 字或双字元素传送到DX指定端口,同时自动 修改SI指针。</p>`,55),e=[i];function t(c,o,S,d,h,r){return n(),s("div",null,e)}const b=a(p,[["render",t]]);export{D as __pageData,b as default};
