import{_ as i,c as l,o as a,a6 as e}from"./chunks/framework.DkFL-jqo.js";const g=JSON.parse('{"title":"概述","description":"","frontmatter":{},"headers":[],"relativePath":"八股/操作系统/输入输出.md","filePath":"八股/操作系统/输入输出.md"}'),s={name:"八股/操作系统/输入输出.md"},t=e(`<h1 id="概述" tabindex="-1">概述 <a class="header-anchor" href="#概述" aria-label="Permalink to &quot;概述&quot;">​</a></h1><h2 id="i-o设备分类" tabindex="-1">I/O设备分类 <a class="header-anchor" href="#i-o设备分类" aria-label="Permalink to &quot;I/O设备分类&quot;">​</a></h2><ol><li><p>与人进行交互</p><ul><li>用于和用户进行通信</li><li>打印机</li><li>视频显示设备 <ul><li>显示器</li><li>键盘</li><li>鼠标</li></ul></li></ul></li><li><p>与设备进行交互用于和电子设备进行通信</p><ul><li>磁盘和磁带</li><li>传感器</li><li>控制器</li><li>传动器</li></ul></li></ol><p>所有设备在操作系统中被粗略地分为两类</p><ol><li><p>按照信息交换的单位：</p><ul><li><p>块设备：以块为单位进行数据传输（可块寻址）</p><ul><li><p>传输快</p></li><li><p>eg：磁盘</p></li></ul></li><li><p>字符设备：以字符为单位进行数据传输</p><ul><li><p>传输慢</p></li><li><p>不可寻址，常采用中断驱动方式</p></li><li><p>eg: 鼠标、键盘</p></li></ul></li></ul></li><li><p>网络设备：网卡、网桥、集线器、路由器、网关…</p></li></ol><ul><li>更多：时钟设备、内存映射的显示器</li></ul><h2 id="i-o设备的不同" tabindex="-1">I/O设备的不同 <a class="header-anchor" href="#i-o设备的不同" aria-label="Permalink to &quot;I/O设备的不同&quot;">​</a></h2><ol><li><p>数据传输率</p><ul><li>不同设备在数据传输率上有可能相差几个数量级</li></ul></li><li><p>应用</p><p>如</p><ul><li>当磁盘用于存储文件时需要文件管理软件的配合</li><li>当磁盘用于存储虚页时需要特殊的硬件和软件的支持</li><li>被系统管理员使用的终端必须具有高级的优先权</li></ul></li><li><p>控制的复杂度</p></li><li><p>传输单位</p><ul><li>对于终端,数据的传输是以字符流为单位,而 磁盘则是以块为单位</li></ul></li><li><p>数据的表示方式</p><ul><li>不同设备编码方式不一样</li></ul></li><li><p>出错表示方式</p></li></ol><h2 id="i-o设备的组成" tabindex="-1">I/O设备的组成 <a class="header-anchor" href="#i-o设备的组成" aria-label="Permalink to &quot;I/O设备的组成&quot;">​</a></h2><ul><li>机械部分</li><li>电子部分</li></ul><blockquote><p>组成设备的电子部分就是设备控制器（一个设备控制器可以处理一类设备）</p></blockquote><p>控制器的任务：</p><ul><li>将串行的位流转换成字节块</li><li>尽可能进行纠错</li><li>可以与主存进行读写操作</li></ul><h2 id="i-o接口基本电路" tabindex="-1">I/O接口基本电路 <a class="header-anchor" href="#i-o接口基本电路" aria-label="Permalink to &quot;I/O接口基本电路&quot;">​</a></h2><p>左边为CPU</p><p><img src="https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241216193305181.png" alt="image-20241216193305181"></p><h2 id="i-o编址" tabindex="-1">I/O编址 <a class="header-anchor" href="#i-o编址" aria-label="Permalink to &quot;I/O编址&quot;">​</a></h2><p><img src="https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241216193513598.png" alt="image-20241216193513598"></p><p>(a)单独的I/O和内存空间</p><p>(b) 内存映射I/O</p><ul><li>控制器中的寄存器与内存地址统一编址。</li></ul><p>(c) 混合方案</p><h2 id="i-o数据传输方式" tabindex="-1">I/O数据传输方式 <a class="header-anchor" href="#i-o数据传输方式" aria-label="Permalink to &quot;I/O数据传输方式&quot;">​</a></h2><ol><li>程序控制I/O <ul><li>在进行输入/输出时，CPU处于一种忙等待</li></ul></li><li>中断驱动I/O <ul><li>CPU发出I/O命令，由控制器具体执行</li><li>CPU转去执行其他指令</li></ul></li><li>控制器完成I/O后，向CPU发中断信号直接存储器存取 (DMA(Direct Memory Access)) <ul><li>由专门的DMA控制器控制数据在内存与外部设备间的传输</li><li>CPU仅仅在所有数据传输结束后进行中断干预</li><li>DMA传送操作</li><li><img src="https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241216202735224.png" alt="image-20241216202735224"></li></ul></li><li>通道控制方式</li></ol><h1 id="i-o数据传输方式-1" tabindex="-1">I/O数据传输方式 <a class="header-anchor" href="#i-o数据传输方式-1" aria-label="Permalink to &quot;I/O数据传输方式&quot;">​</a></h1><h2 id="程序控制i-o" tabindex="-1">程序控制I/O <a class="header-anchor" href="#程序控制i-o" aria-label="Permalink to &quot;程序控制I/O&quot;">​</a></h2><blockquote><p>在进行输入/输出时，CPU处于一种忙等待（轮询）</p></blockquote><h4 id="打印一个字符串的步骤" tabindex="-1">打印一个字符串的步骤 <a class="header-anchor" href="#打印一个字符串的步骤" aria-label="Permalink to &quot;打印一个字符串的步骤&quot;">​</a></h4><p><img src="https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241216203232686.png" alt="image-20241216203232686"></p><p>使用程序控制I/O将一个字符串写到打印机</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">copy_from_user</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(buffer,p,count);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> //p：内核空间缓存</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">count;i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">printer_status_reg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">READY);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> //忙等待循环，等待打印机的状态寄存器变为READY</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">printer_data_register </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[i];</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> //输出一个字符</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">return_to_user</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><h2 id="中断驱动i-o" tabindex="-1">中断驱动I/O <a class="header-anchor" href="#中断驱动i-o" aria-label="Permalink to &quot;中断驱动I/O&quot;">​</a></h2><blockquote><ol><li><p>方式：</p><ul><li><p>CPU发出I/O命令，由控制器具体执行</p></li><li><p>CPU转去执行其他指令，知道CPU收到控制器中断信号。</p></li></ul></li><li><p>优点：</p><ul><li>CPU和IO可并行工作CPU利用率明显提升</li></ul></li><li><p>缺点:</p><ul><li>中断处理会消耗大量CPU时间</li></ul></li></ol></blockquote><h2 id="dma-直接存储器存取" tabindex="-1">DMA(直接存储器存取) <a class="header-anchor" href="#dma-直接存储器存取" aria-label="Permalink to &quot;DMA(直接存储器存取)&quot;">​</a></h2><blockquote><ol><li>方式： <ul><li>控制器完成I/O后，向CPU发中断信号直接存储器存取</li></ul></li><li>说明: <ul><li>由专门的DMA控制器控制数据在内存与外部设备间的传输</li><li>CPU仅仅在所有数据传输结束后进行中断干预</li><li>数据传输方式为“块”，不再是前两种方式的“字”</li></ul></li></ol></blockquote><p>DMA传送操作:<img src="https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241228155546443.png" alt="image-20241228155546443"></p><h2 id="通道控制方式" tabindex="-1">通道控制方式 <a class="header-anchor" href="#通道控制方式" aria-label="Permalink to &quot;通道控制方式&quot;">​</a></h2><p><img src="https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241228160215180.png" alt="image-20241228160215180"></p><h1 id="i-o-软件" tabindex="-1">I/O 软件 <a class="header-anchor" href="#i-o-软件" aria-label="Permalink to &quot;I/O 软件&quot;">​</a></h1><h2 id="i-o软件的目标" tabindex="-1">I/O软件的目标 <a class="header-anchor" href="#i-o软件的目标" aria-label="Permalink to &quot;I/O软件的目标&quot;">​</a></h2><ol><li><p>设备独立性</p><ul><li>程序能够访问任意的设备</li><li>不需要事先指定(如读取硬盘, 软盘, 或光驱)</li></ul></li><li><p>统一命名</p><ul><li>一个文件或设备的名字应该是一个简单的字符串或一个整数</li><li>不应依赖于任何设备</li></ul></li><li><p>错误处理</p><ul><li>错误应该尽可能在接近硬件层面得到处理</li></ul></li><li><p>同步(Synchronous)和异步( asynchronous) 传输</p><ul><li>阻塞式传输和中断驱动传输</li></ul></li><li><p>缓冲</p><ul><li>数据离开一个设备后通常并不能直接存放到目的地</li></ul></li><li><p>共享设备和独占设备</p><ul><li>磁盘是共享设备</li><li>磁带是独占性设备</li></ul></li></ol><h2 id="i-o-软件层次" tabindex="-1">I/O 软件层次 <a class="header-anchor" href="#i-o-软件层次" aria-label="Permalink to &quot;I/O 软件层次&quot;">​</a></h2><p><img src="https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241228170743584.png" alt="image-20241228170743584"></p><p>I/O系统的层次以及每一层的主要功能:</p><p><img src="https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241228172914263.png" alt="image-20241228172914263"></p><p><img src="https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241228172927625.png" alt="image-20241228172927625"></p><h3 id="中断处理程序" tabindex="-1">中断处理程序 <a class="header-anchor" href="#中断处理程序" aria-label="Permalink to &quot;中断处理程序&quot;">​</a></h3><ul><li><p>中断向量程序应该隐藏在操作系统内部</p><ul><li>将启动I/O操作的驱动程序阻塞起来,直到I/O操 作完成且产生一个中断</li></ul></li><li><p>中断处理程序将完成它所要做的全部工作</p><ul><li>然后将启动中断的驱动程序解除阻塞</li></ul></li><li><p>硬件中断完成之后软件中断的执行步骤</p><ol><li>保存没有被中断硬件保存的所有寄存器</li><li>为中断服务过程设置上下文,可能包括设置 TLB,MMU和页表</li><li>为中断服务过程设置堆栈</li><li>应答中断控制器,如果不存在集中的中断控制器, 则再次开放中断</li><li>将寄存器从它们被保存的地方复制到进程表中</li><li>运行中断服务过程,从发出中断的设备控制器的 寄存器中提取信息</li><li>选择下一次运行哪一个进程</li><li>为下一次要运行的进程设置MMU上下文</li><li>装入新进程的寄存器</li><li>开始运行新进程</li></ol></li></ul><h3 id="设备驱动程序" tabindex="-1">设备驱动程序 <a class="header-anchor" href="#设备驱动程序" aria-label="Permalink to &quot;设备驱动程序&quot;">​</a></h3><blockquote><p>概念：驱动物理设备和ＤＭＡ／Ｉ／Ｏ控制器等直接进 行Ｉ／Ｏ操作的子程序的集合，它是低级的系统例程, 使用特权指令访问硬件，在系统初始化时启动（常由汇编或系统编程语言写成）</p></blockquote><p>处理过程：</p><ul><li>将抽象要求转换为具体要求</li><li>检查Ｉ／Ｏ请求的合法性</li><li>读出和检查设备状态</li><li>传送必要参数</li><li>方式设置</li><li>启动Ｉ／Ｏ设备</li></ul><p><img src="https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241229110030578.png" alt="image-20241229110030578"></p><h3 id="与设备无关的i-o软件" tabindex="-1">与设备无关的I/O软件 <a class="header-anchor" href="#与设备无关的i-o软件" aria-label="Permalink to &quot;与设备无关的I/O软件&quot;">​</a></h3><p><img src="https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241229110306450.png" alt="image-20241229110306450"></p><h4 id="缓冲区管理" tabindex="-1">缓冲区管理 <a class="header-anchor" href="#缓冲区管理" aria-label="Permalink to &quot;缓冲区管理&quot;">​</a></h4><p><img src="https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241229110420035.png" alt="image-20241229110420035"></p><h5 id="双缓冲" tabindex="-1">双缓冲 <a class="header-anchor" href="#双缓冲" aria-label="Permalink to &quot;双缓冲&quot;">​</a></h5><blockquote><ul><li>使用两个系统内核空间中的缓冲</li><li>当第一个缓冲区被填满之后,在它被清空之前 可以使用第二个缓冲区</li></ul></blockquote><p><img src="https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241229110516573.png" alt="image-20241229110516573"></p><h5 id="循环缓冲" tabindex="-1">循环缓冲 <a class="header-anchor" href="#循环缓冲" aria-label="Permalink to &quot;循环缓冲&quot;">​</a></h5><blockquote><ul><li>可以使用的缓冲区有两个以上</li><li>Each individual buffer is one unit in a circular buffer</li><li>Used when I/O operation must keep up with process</li></ul></blockquote><p><img src="https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241229110616438.png" alt="image-20241229110616438"></p><h5 id="缓冲池" tabindex="-1">缓冲池 <a class="header-anchor" href="#缓冲池" aria-label="Permalink to &quot;缓冲池&quot;">​</a></h5><blockquote><ul><li>这是一种双方向缓冲技术；缓冲区整体利用率高。</li><li>缓冲区队列：三种：空闲缓冲区，输入缓冲区，输 出缓冲区</li><li>操作：四种：设备输入，CPU读入，设备输出， CPU写出。上述操作访问各个缓冲区队列时，需要 进行相应的互斥操作。</li></ul></blockquote><p><img src="https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241229110738268.png" alt="image-20241229110738268"></p><h1 id="spooling-假脱机-虚拟设备技术" tabindex="-1">SPOOLing(假脱机,虚拟设备技术) <a class="header-anchor" href="#spooling-假脱机-虚拟设备技术" aria-label="Permalink to &quot;SPOOLing(假脱机,虚拟设备技术)&quot;">​</a></h1><blockquote><p>引入：在多道批处理系统中，专门利用一道程序（SPOOLing 程序）来完成对设备的I/O操作。无需使用外围I/O处理机。</p></blockquote><p><img src="https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241228173551098.png" alt="image-20241228173551098"></p><p>可把独享设备转变成具有共享特征的虚拟设备，从而提高设备利用率。</p><p><img src="https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241228173651119.png" alt="image-20241228173651119"></p><h1 id="盘" tabindex="-1">盘 <a class="header-anchor" href="#盘" aria-label="Permalink to &quot;盘&quot;">​</a></h1><h2 id="盘的硬件" tabindex="-1">盘的硬件 <a class="header-anchor" href="#盘的硬件" aria-label="Permalink to &quot;盘的硬件&quot;">​</a></h2><p><img src="https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241229111215505.png" alt="image-20241229111215505"></p><p><img src="https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241229111345116.png" alt="image-20241229111345116"></p><h2 id="磁头臂调度" tabindex="-1">磁头臂调度 <a class="header-anchor" href="#磁头臂调度" aria-label="Permalink to &quot;磁头臂调度&quot;">​</a></h2><blockquote><ul><li><p>读写一个磁盘块的时间由下面三个时间因素构成:</p><ol><li>寻道时间</li><li>旋转延迟</li><li>实际数据传输时间</li></ol></li><li><p>寻道时间占主导地位</p></li><li><p>传输过程中的纠错由控制器完成</p></li></ul></blockquote><h3 id="磁头臂调度策略" tabindex="-1">磁头臂调度策略 <a class="header-anchor" href="#磁头臂调度策略" aria-label="Permalink to &quot;磁头臂调度策略&quot;">​</a></h3><h4 id="先来先服务-fcfs-fifo" tabindex="-1">先来先服务(FCFS/FIFO) <a class="header-anchor" href="#先来先服务-fcfs-fifo" aria-label="Permalink to &quot;先来先服务(FCFS/FIFO)&quot;">​</a></h4><blockquote><ul><li>按达到顺序满足进程的需求</li><li>对所有进程都公平</li><li>在磁盘I/O负载较轻且每次读写多个连续扇区时， 性能较好</li></ul></blockquote><p><img src="https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241229112851351.png" alt="image-20241229112851351"></p><h4 id="最短寻道时间优先-sstf" tabindex="-1">最短寻道时间优先(SSTF) <a class="header-anchor" href="#最短寻道时间优先-sstf" aria-label="Permalink to &quot;最短寻道时间优先(SSTF)&quot;">​</a></h4><blockquote><p>考虑磁盘I/O请求队列中各请求的磁头定位位置，选 择从当前磁头位置出发，移动最少的磁盘I/O请求</p></blockquote><ul><li>该算法的目标是使每次磁头移动时间最少。它不一 定是最短平均柱面定位时间，但比FIFO算法有更好的性能。</li><li>对中间的磁道有利，可能会有进程处于饥饿状态。</li></ul><p><img src="https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241229113149868.png" alt="image-20241229113149868"></p><p><img src="https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241229113413074.png" alt="image-20241229113413074"></p><h4 id="scan-elevator-algorithm-扫描算法-电梯算法" tabindex="-1">SCAN(elevator algorithm,扫描算法,电梯算法) <a class="header-anchor" href="#scan-elevator-algorithm-扫描算法-电梯算法" aria-label="Permalink to &quot;SCAN(elevator algorithm,扫描算法,电梯算法)&quot;">​</a></h4><blockquote><ul><li>选择在磁头前进方向上从当前位置移动最少的磁 盘I/O请求执行，没有前进方向上的请求时才改变方向。</li><li>该算法是对SSTF算法的改进，磁盘I/O较好，且 没有进程会饿死。</li></ul></blockquote><p><img src="https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241229114235270.png" alt="image-20241229114235270"></p><h4 id="c-scan-循环扫描" tabindex="-1">C-SCAN(循环扫描) <a class="header-anchor" href="#c-scan-循环扫描" aria-label="Permalink to &quot;C-SCAN(循环扫描)&quot;">​</a></h4><blockquote><ul><li>严格按照一个方向进行扫描,在一个方向上使用 扫描算法，当到达边沿时直接移动到另一沿的第 一个位置。</li><li>该算法可改进扫描算法对中间磁道的偏好。实验表明，该算法在中负载或重负载时，磁盘I/O性能比扫描算法好。</li></ul></blockquote><p>上例中扫描完36，直接转去扫描1，再扫描9</p><h4 id="优先级" tabindex="-1">优先级 <a class="header-anchor" href="#优先级" aria-label="Permalink to &quot;优先级&quot;">​</a></h4><ul><li>目标是系统目标的实现，而不是改进磁盘I/O性 能</li><li>短作业具有较高优先级</li><li>反映进程在系统的优先级特征,具有较好系统交 互响应时间</li></ul><h4 id="后进先出" tabindex="-1">后进先出 <a class="header-anchor" href="#后进先出" aria-label="Permalink to &quot;后进先出&quot;">​</a></h4><ul><li>该算法是基于事务系统中顺序文件中磁盘I/O的局部性特征，相邻访问的位置也相邻。</li><li>它的问题在于系统负载重时，可能有进程的磁盘I/O 永远不能执行，处于饥饿状态。</li></ul><h3 id="减少旋转延迟的方法" tabindex="-1">减少旋转延迟的方法 <a class="header-anchor" href="#减少旋转延迟的方法" aria-label="Permalink to &quot;减少旋转延迟的方法&quot;">​</a></h3><ol><li><p>交替编号</p><ul><li>做法：让编号相邻的扇区在物理上不相邻</li><li>原理：读完一个删除，需要一段时间处理才可以读下一个扇区</li><li><img src="https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241229115700211.png" alt="image-20241229115700211"></li></ul></li><li><p>柱面斜进(错位命名)</p><ul><li>做法：让相邻盘面的扇区编号“错位”</li></ul><p><img src="https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241229115933218.png" alt="image-20241229115933218"></p></li></ol>`,98),o=[t];function p(h,n,r,c,u,d){return a(),l("div",null,o)}const k=i(s,[["render",p]]);export{g as __pageData,k as default};
