import{_ as i,c as l,o as s,a6 as a}from"./chunks/framework.DkFL-jqo.js";const c=JSON.parse('{"title":"第 1 章","description":"","frontmatter":{},"headers":[],"relativePath":"八股/网安/软件安全/2022210774吴俊杰.md","filePath":"八股/网安/软件安全/2022210774吴俊杰.md"}'),t={name:"八股/网安/软件安全/2022210774吴俊杰.md"},n=a(`<h1 id="第-1-章" tabindex="-1">第 1 章 <a class="header-anchor" href="#第-1-章" aria-label="Permalink to &quot;第 1 章&quot;">​</a></h1><h2 id="_1" tabindex="-1">1 <a class="header-anchor" href="#_1" aria-label="Permalink to &quot;1&quot;">​</a></h2><blockquote><p>什么是软件安全？软件为什么会存在安全问题？</p></blockquote><p>软件安全：软件安全是指确保软件在开发、部署和运行过程中，能够有效防范各种潜在的安全威胁、攻击和漏洞，从而保护系统和数据的机密性、完整性和可用性。软件安全不仅仅是防止黑客攻击，还包括确保软件能够在出现问题时正确处理，避免意外或恶意破坏。</p><p>软件为什么会存在安全问题：</p><ul><li><p>设计缺陷：没有从一开始就考虑安全，导致漏洞。</p></li><li><p>编程错误：开发中的编码问题（如SQL注入、缓冲区溢出）。</p></li><li><p>缺乏安全测试：未进行充分的安全测试，漏洞未被发现。</p></li><li><p>更新不及时：软件发布后未及时修复已知漏洞。</p></li></ul><h2 id="_2" tabindex="-1">2 <a class="header-anchor" href="#_2" aria-label="Permalink to &quot;2&quot;">​</a></h2><blockquote><p>软件面临的具体安全威胁有哪些？</p></blockquote><ul><li>软件漏洞 <ul><li>代码中的缺陷或弱点，攻击者可以利用这些漏洞进行攻击（如SQL注入、缓冲区溢出等）。</li></ul></li><li>恶意软件 <ul><li>包括病毒、木马、勒索软件等，旨在破坏、窃取数据或控制系统。</li></ul></li><li>软件侵权 <ul><li>使用未经授权的第三方软件，可能导致安全风险，也可能触犯版权或许可协议，带来法律后果。</li></ul></li><li>软件后门 <ul><li>攻击者通过秘密植入的后门程序，绕过正常的安全控制，获得未经授权的访问权限。</li></ul></li></ul><h2 id="_3" tabindex="-1">3 <a class="header-anchor" href="#_3" aria-label="Permalink to &quot;3&quot;">​</a></h2><blockquote><p>面对当前的全球网络空间安全威胁，为什么必须重点关注软件安全？</p></blockquote><ol><li>软件是攻击的主要目标 <ul><li>随着越来越多的应用程序和服务依赖于软件，攻击者通过利用软件中的漏洞进行攻击（如SQL注入、缓冲区溢出、XSS等），已成为网络攻击的主要手段。软件漏洞往往是黑客入侵的突破口。</li></ul></li><li>全球网络依赖 <ul><li>软件已成为全球经济和社会运作的基础，金融系统、医疗保健、能源供应等关键基础设施都依赖于软件。软件一旦受到攻击，可能引发大规模的社会、经济甚至政治影响。因此，保护软件安全至关重要。</li></ul></li><li>复杂的网络威胁 <ul><li>当前的网络攻击越来越复杂，攻击者不仅利用传统的漏洞，还会通过社会工程学、恶意软件、零日漏洞等手段对软件进行攻击。为了有效防御这些威胁，必须关注软件的安全性，确保其能够防止各种新型攻击。</li></ul></li></ol><h2 id="_4" tabindex="-1">4 <a class="header-anchor" href="#_4" aria-label="Permalink to &quot;4&quot;">​</a></h2><blockquote><p>软件安全的概念及其属性是什么？</p></blockquote><p><strong>软件安全</strong>是指在软件生命周期的各个阶段，采取一系列措施和技术，以保证软件系统的机密性、完整性、可用性，并防止未授权访问、修改或破坏。软件安全的目标是确保软件在面对攻击或错误时能有效地防范和应对，保证数据和系统的安全性与稳定性。</p><p>属性：保密性、完整性、可用性、可认证性、授权、可审计性、抗抵赖性、可控性、可存活性。</p><h1 id="第-2-章" tabindex="-1">第 2 章 <a class="header-anchor" href="#第-2-章" aria-label="Permalink to &quot;第 2 章&quot;">​</a></h1><h2 id="_1-1" tabindex="-1">1 <a class="header-anchor" href="#_1-1" aria-label="Permalink to &quot;1&quot;">​</a></h2><blockquote><p>软件安全开发过程是什么？</p></blockquote><p>软件安全开发过程是指为了获得高质量软件所需要完成的一系列任务的框架，包括从软件开发到完成所经历的软件生命周期。</p><h2 id="_2-1" tabindex="-1">2 <a class="header-anchor" href="#_2-1" aria-label="Permalink to &quot;2&quot;">​</a></h2><blockquote><p>软件出现安全漏洞，可能产生的软件安全威胁有哪些？</p></blockquote><p>数据泄露：敏感数据被未授权访问或公开，可能导致隐私泄露和财务损失。</p><p>代码注入（Code Injection）：攻击者通过注入恶意代码（如SQL注入、命令注入）控制系统，获取敏感信息或执行恶意操作。</p><p>远程代码执行（RCE）：攻击者利用漏洞远程执行恶意代码，完全控制目标系统。</p><p>拒绝服务攻击（DoS/DDoS）：通过消耗系统资源使目标无法正常工作，导致服务中断。</p><p>跨站脚本（XSS）：攻击者注入恶意脚本，通过浏览器劫持用户信息，进行钓鱼攻击或传播恶意软件。</p><p>跨站请求伪造（CSRF）：攻击者诱导认证用户执行未授权操作，可能导致系统漏洞或数据损失。</p><p>恶意软件：通过漏洞传播病毒、木马等恶意程序，破坏系统或窃取数据。</p><p>社会工程学攻击：通过欺骗和操控用户获取敏感信息或访问权限。</p><h2 id="_3-1" tabindex="-1">3 <a class="header-anchor" href="#_3-1" aria-label="Permalink to &quot;3&quot;">​</a></h2><blockquote><p>软件开发模型（SDL）可以分为哪几个阶段</p></blockquote><ol><li>安全培训</li><li>安全需求分析</li><li>安全设计</li><li>安全编程</li><li>安全验证</li><li>安全发布</li><li>安全响应</li></ol><h2 id="_4-1" tabindex="-1">4 <a class="header-anchor" href="#_4-1" aria-label="Permalink to &quot;4&quot;">​</a></h2><blockquote><p>对比分析四种安全开发模型SDL、SAMM、BSIMM和TSP-Secure的技术特点和应用场景</p></blockquote><ul><li><strong>SDL</strong> 适用于全生命周期安全集成；</li><li><strong>SAMM</strong> 和 <strong>BSIMM</strong> 侧重安全成熟度评估，<strong>SAMM</strong> 灵活，<strong>BSIMM</strong> 注重实践；</li><li><strong>TSP-Secure</strong> 强调团队协作和过程中的安全集成。</li></ul><h1 id="第-3-章" tabindex="-1">第 3 章 <a class="header-anchor" href="#第-3-章" aria-label="Permalink to &quot;第 3 章&quot;">​</a></h1><h2 id="_1-2" tabindex="-1">1 <a class="header-anchor" href="#_1-2" aria-label="Permalink to &quot;1&quot;">​</a></h2><blockquote><p>为什么要进行软件安全需求分析？</p></blockquote><p><strong>识别潜在风险</strong>：帮助开发团队发现并规避安全漏洞和威胁。</p><p><strong>确保合规性</strong>：确保软件符合法律和行业标准，避免合规问题。</p><p><strong>降低修复成本</strong>：在开发初期发现问题，减少后期修复的时间和成本。</p><p><strong>提高可靠性</strong>：增强系统抗攻击能力，提升软件稳定性。</p><p><strong>保护用户数据</strong>：确保敏感数据的安全，防止泄露和滥用。</p><p><strong>增强用户信任</strong>：增加软件的安全性，提升用户对产品的信任。</p><p><strong>支持持续改进</strong>：为软件生命周期内的安全更新和维护提供基础。</p><h2 id="_6" tabindex="-1">6 <a class="header-anchor" href="#_6" aria-label="Permalink to &quot;6&quot;">​</a></h2><blockquote><p>软件安全架构设计的基本过程是什么？</p></blockquote><p>需求分析、威胁建模、架构设计、风险评估、测试验证、文档编写以及持续维护</p><h2 id="_7" tabindex="-1">7 <a class="header-anchor" href="#_7" aria-label="Permalink to &quot;7&quot;">​</a></h2><blockquote><p>什么是最小攻击面原则？试举例说明在软件设计时实现最小攻击面的措施</p></blockquote><p>最小攻击面原则是一种安全设计原则，旨在通过减少软件系统中可能受到攻击的入口点或暴露的组件来降低潜在的安全风险。其基本思想是尽量减小攻击者能够利用的攻击面，以减少系统遭受攻击的可能性。其中软件的攻击面是指用户、潜在攻击者和其他程序所能访问的所有软件功能与代码的总和。</p><p>措施：</p><ul><li><p>减少不必要的功能和服务</p><ul><li>措施：在设计和实现时，禁用所有不必要的功能和服务，只保留最基本和最必要的功能。</li><li>举例：如果一个应用不需要FTP或SSH功能，那么应该完全禁用这些服务，避免它们成为攻击的入口。</li></ul></li><li><p>限制网络端口和协议的暴露</p><ul><li><p>措施：确保只暴露必须的网络端口，限制外部可访问的网络协议。</p></li><li><p>举例：如果一个Web应用只需要HTTP和HTTPS服务，就不要暴露Telnet或其他不必要的端口。如果可能，使用防火墙控制只允许特定IP地址访问某些端口。</p></li></ul></li><li><p>使用最小权限原则</p><ul><li>措施：确保每个用户、进程和模块只能访问其执行任务所必需的资源，避免过多的权限赋予。</li><li>举例：数据库连接只赋予查询所需的权限，而不授予写入或删除权限。</li></ul></li></ul><h2 id="_8" tabindex="-1">8 <a class="header-anchor" href="#_8" aria-label="Permalink to &quot;8&quot;">​</a></h2><blockquote><p>什么是纵深防御原则？试举例说明在软件设计时实现的纵深防御的措施</p></blockquote><p>纵深防御原则是指在软件设计中采用多重安全机制的防御技术。</p><p>措施：防火墙、入侵检测系统、监控</p><h1 id="第-4-章" tabindex="-1">第 4 章 <a class="header-anchor" href="#第-4-章" aria-label="Permalink to &quot;第 4 章&quot;">​</a></h1><h2 id="_1-3" tabindex="-1">1 <a class="header-anchor" href="#_1-3" aria-label="Permalink to &quot;1&quot;">​</a></h2><blockquote><p>下面这段代码存在什么安全缺陷?应当如何修复其缺陷?</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> input</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	char</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> buffer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">25</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Input is: &quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	strcat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (buffer, input) ; </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></blockquote><p>缓冲区溢出</p><p>修复：</p><ul><li>检查数据长度</li><li>使用安全函数或函数库</li><li>栈保护、非执行堆栈技术</li></ul><h2 id="_5" tabindex="-1">5 <a class="header-anchor" href="#_5" aria-label="Permalink to &quot;5&quot;">​</a></h2><blockquote><p>阅读下面的代码，分析将语句&quot;System.out.print(&quot;程序结束&quot;):”放在位置①和位置②有何不同?代码中的finally语句是否可以删去?</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> securitySquare</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> void main(String[] args) {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	Scanner scan . </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Scanner</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (System.in) ;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	System. out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;请输人一个数字:&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> input . scan.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">nextInt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() ;</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	System. out </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(input </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;的平方为&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> input</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> input);</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (InputMi </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">smatchException</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    System. out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;输入数字类型有误!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">finally {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ①</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   ②</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></blockquote><p><strong>放在位置①（<code>finally</code> 块中）</strong>：无论是否发生异常，<code>finally</code> 中的代码都会执行，确保“程序结束”始终被输出。</p><p><strong>放在位置②（<code>try</code> 或 <code>catch</code> 块之后）</strong>：如果发生了异常且未被捕获或正确处理，<code>System.out.print(&quot;程序结束&quot;);</code> 可能不会执行，因为程序可能会提前终止。此时，<code>finally</code> 块会确保资源清理和语句执行。</p><p>代码中的finally语句不能删除，finally语句，确保资源被正确释放，防止资源泄漏。删除 <code>finally</code> 块可能导致资源未被正确关闭，影响程序的健壮性和性能。</p><h2 id="_9" tabindex="-1">9 <a class="header-anchor" href="#_9" aria-label="Permalink to &quot;9&quot;">​</a></h2><blockquote><p>Web应用中常见的安全漏洞有哪些？如何应对这些安全漏洞？</p></blockquote><ul><li>SQL注入 <ul><li>输入验证和过滤：对用户输入进行严格的检查，拒绝特殊字符（如单引号 <code>&#39;</code>，双引号 <code>&quot;</code>，分号 <code>;</code>）的输入。</li><li>使用ORM框架：如Hibernate或MyBatis等，它们默认使用预编译语句，减少SQL注入的风险。</li></ul></li><li>跨站脚本攻击（XSS） <ul><li>禁用JavaScript：对用户的输入进行严格的过滤，确保不允许注入 <code>&lt;script&gt;</code> 标签或其他可执行的代码。</li></ul></li><li>跨站请求伪造（CSRF） <ul><li><strong>验证Referer头</strong>：检查HTTP请求中的<code>Referer</code>头，确保请求来自可信的源站点。</li><li><strong>使用防CSRF令牌</strong>：为每个用户会话生成一个唯一的CSRF令牌，并在每次提交表单时验证该令牌。常见的做法是将令牌放在HTTP请求的头部或者作为表单字段。</li></ul></li><li>文件上传漏洞</li><li><strong>件类型限制</strong>：只允许上传特定类型的文件（如图片、PDF等）。检查文件扩展名和文件内容（如MIME类型），而不仅仅是文件名。</li><li><strong>隔离存储路径</strong>：不要将上传的文件直接存放在Web可访问的目录中，应将其存放在专门的目录或文件服务器中。</li></ul><h2 id="_12" tabindex="-1">12 <a class="header-anchor" href="#_12" aria-label="Permalink to &quot;12&quot;">​</a></h2><blockquote><p>开发一个安全的Web应用程序需要注意哪些问题？</p></blockquote><ul><li><strong>数据加密</strong>：使用HTTPS加密传输，存储密码采用哈希算法，敏感数据加密。</li><li><strong>漏洞防护</strong>：注意常见漏洞如sql注入、xss防护、文件上传安全等的防护。</li><li><strong>DDoS防护</strong>：使用CDN、速率限制和防火墙应对拒绝服务攻击。</li></ul><h1 id="第-5-章" tabindex="-1">第 5 章 <a class="header-anchor" href="#第-5-章" aria-label="Permalink to &quot;第 5 章&quot;">​</a></h1><h3 id="_1-4" tabindex="-1">1 <a class="header-anchor" href="#_1-4" aria-label="Permalink to &quot;1&quot;">​</a></h3><blockquote><p>软件安全测试的目标是什么？</p></blockquote><p>软件安全测试的目标是识别被测软件中的安全威胁和安全漏洞，以帮助开发团队降低软件系统的安全风险，使系统在威胁时不会停止运行或被利用。</p><h2 id="_2-2" tabindex="-1">2 <a class="header-anchor" href="#_2-2" aria-label="Permalink to &quot;2&quot;">​</a></h2><blockquote><p>软件安全测试的一般需求是什么？</p></blockquote><ol><li>漏洞识别</li><li>风险分析</li><li>攻击面分析</li></ol><h2 id="_3-2" tabindex="-1">3 <a class="header-anchor" href="#_3-2" aria-label="Permalink to &quot;3&quot;">​</a></h2><blockquote><p>软件安全测试的方法有哪些？</p></blockquote><ol><li>基于模型的安全测试</li><li>基于代码的静态安全测试</li><li>动态安全测试</li><li>安全回归测试</li></ol><h1 id="第-6-章" tabindex="-1">第 6 章 <a class="header-anchor" href="#第-6-章" aria-label="Permalink to &quot;第 6 章&quot;">​</a></h1><h2 id="_1-5" tabindex="-1">1 <a class="header-anchor" href="#_1-5" aria-label="Permalink to &quot;1&quot;">​</a></h2><blockquote><p>什么是软件漏洞？软件漏洞形成的原因是什么？</p></blockquote><p>软件漏洞是在软件系统的设计、实现、安全策略配置和运行中存在的安全缺陷，使得系统或其应用数据的保密性、完整性、可用性和访问控制等面临威胁，导致攻击者在未授权的情况下访问或破坏系统。</p><p>原因：</p><ol><li>计算机系统的结构决定了漏洞的必然性。</li><li>软件趋向大型化，第三方组件增多。</li><li>新的技术或应用在产生之初缺乏安全性考虑。</li><li>软件应用场景中有更多的安全威胁。</li><li>软件开发者的安全意识不够高，对软件安全开发重视不够。</li></ol><h2 id="_2-3" tabindex="-1">2 <a class="header-anchor" href="#_2-3" aria-label="Permalink to &quot;2&quot;">​</a></h2><blockquote><p>软件漏洞被利用的后果有哪些？</p></blockquote><ol><li>数据泄露 <ul><li>个人隐私数据泄露：例如，用户的敏感信息（如姓名、地址、电话号码、身份证号、银行卡信息等）可能被未经授权的第三方获取。</li><li>公司机密泄露：公司内部的敏感数据，如财务数据、商业机密、客户信息等，可能被泄露，导致竞争对手获得不正当优势。</li><li>知识产权盗窃：公司研发的技术、软件源代码、产品设计等可能被盗用或泄露。</li></ul></li><li>系统控制权被攻陷</li><li>恶意软件传播 <ul><li>病毒、木马和勒索软件：攻击者通过漏洞植入恶意软件，进一步扩大攻击范围，感染其他系统，甚至要求赎金才能解锁受害者的文件（勒索软件）。</li></ul></li></ol><h2 id="_4-2" tabindex="-1">4 <a class="header-anchor" href="#_4-2" aria-label="Permalink to &quot;4&quot;">​</a></h2><blockquote><p>软件漏洞如何分类分级管理？</p></blockquote><p>分类：</p><ol><li>基于成因的软件漏洞分类 <ul><li>软件设计漏洞</li><li>代码实现漏洞</li><li>开放式协议导致的漏洞</li><li>人为因素引起的漏洞</li></ul></li><li>基于生命周期的软件漏洞分类 <ul><li>未知漏洞</li><li>已知漏洞</li><li>未公开漏洞</li><li>已公开漏洞</li><li>0day漏洞</li><li>1day漏洞</li><li>历史漏洞</li></ul></li></ol><p>分级：</p><ol><li>按照漏洞的严重程度分级</li><li>按照漏洞评分系统（CVSS）分级</li></ol><h2 id="_5-1" tabindex="-1">5 <a class="header-anchor" href="#_5-1" aria-label="Permalink to &quot;5&quot;">​</a></h2><blockquote><p>为什么要对软件漏洞进行管控？</p></blockquote><ol><li>随着信息系统在社会、政治、经济等各个领域深入而广泛的应用，对软件系统中漏洞的管控变得越来越重要。</li><li>近年来高危漏洞不断增多，其触发的病毒传播、挂马攻击、系统故障、信息泄露、数据丢失以及黑客入侵等信息安全事件呈大幅增长态势。</li><li>软件漏洞具有隐蔽性，难以发现和消除，对国家、单位和个人的信息安全造成了严重的冲击和影响，对软件漏洞的管控势在必行。</li></ol><h1 id="第-7-章" tabindex="-1">第 7 章 <a class="header-anchor" href="#第-7-章" aria-label="Permalink to &quot;第 7 章&quot;">​</a></h1><h2 id="_1-6" tabindex="-1">1 <a class="header-anchor" href="#_1-6" aria-label="Permalink to &quot;1&quot;">​</a></h2><blockquote><p>什么是内存漏洞？内存漏洞产生的原因是什么？</p></blockquote><p>内存漏洞是指攻击者利用软件的设计缺陷或编码缺陷，构造恶意输入数据，目的是使软件在处理这些数据时出现非预期的错误，进而劫持软件控制流，使之转而执行外部输入的指令代码，从而使得目标系统运行攻击者预设的攻击操作。</p><p>原因：在采用了冯.诺依曼结构的计算机中，指令和数据没有本质区别，系统无法区分内存中的二进制串是指令还是数据。</p><h2 id="_5-2" tabindex="-1">5 <a class="header-anchor" href="#_5-2" aria-label="Permalink to &quot;5&quot;">​</a></h2><blockquote><p>在代码的编写中如何避免释放后重用漏洞？</p></blockquote><ol><li>正确管理内存生命周期 <ul><li>避免悬空指针</li></ul></li><li>使用内存池和对象池 <ul><li>内存池（Memory Pool）和对象池（Object Pool）管理内存的分配和回收，可以减少频繁的内存分配与释放，降低UAF的风险。对象池会在对象被销毁时将其重新放回池中，而不是立即释放，从而避免内存被提前释放并重新使用的情况。</li></ul></li><li>避免内存过度释放 <ul><li>避免重复释放内存：同一块内存如果被多次释放，程序可能会遇到未定义行为。确保每个内存块只被释放一次，并且释放后的指针立即置为<code>NULL</code>。</li></ul></li></ol><h2 id="_7-1" tabindex="-1">7 <a class="header-anchor" href="#_7-1" aria-label="Permalink to &quot;7&quot;">​</a></h2><blockquote><p>根据OWASP在2021年发布的安全报告，Web漏洞分为哪几大类型？</p></blockquote><ol><li>失效的访问控制</li><li>加密失败</li><li>注入</li><li>不安全的设计</li><li>安全配置错误</li><li>有漏洞的过时组件</li><li>身份验证和认证失败</li><li>软件和数据的完整性失效</li><li>安全日志记录和监控失效</li><li>服务器端请求伪造</li></ol><h2 id="_11" tabindex="-1">11 <a class="header-anchor" href="#_11" aria-label="Permalink to &quot;11&quot;">​</a></h2><blockquote><p>分析下面这段代码是否存在安全漏洞，若有，请给出漏洞利用方法</p><div class="language-php vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">php</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;?</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">php</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">($_GET[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;id&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    $id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $_GET[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;id&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    $mysqli </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> mysqli</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;localhost&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;dbuser&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;dbpasswd&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;example&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ($mysqli</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">connect_errno) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;COnnect failed:%s</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, $mysqli</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">connect_errno);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        exit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    $sql </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SELECT</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> username </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">FROM</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> users </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">WHERE</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $id</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ($result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $mysqli</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">query</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">($sql)){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ($obj</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$result</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fetch_object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()){</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">            print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ($obj</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">username);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">elseif</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ($mysqli</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">error){</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">($mysqli</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">error);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></blockquote><p>存在SQL注入漏洞</p><p>漏洞利用方法：</p><ol><li>在下面这行代码<code>$sql = &quot;SELECT username FROM users WHERE id = $id&quot;;</code>中，<code>$id</code> 变量的值来自用户输入，使用了 <code>$_GET[&#39;id&#39;]</code>。控制 <code>id</code> 参数的值，来操控SQL查询，执行任意的SQL命令。</li><li>例如<code>SELECT username FROM users WHERE id = 1 OR 1=1</code>查询将返回数据库中所有的用户名，因为 <code>1=1</code> 是始终成立的条件。</li><li>在访问网页时便可以通过控制?后面的参数来执行想要执行的sql语句，例如查看所有用户的用户名 <a href="http://xxxx?id=-1" target="_blank" rel="noreferrer">http://xxxx?id=-1</a> OR 1=1</li></ol><h1 id="第-8-章" tabindex="-1">第 8 章 <a class="header-anchor" href="#第-8-章" aria-label="Permalink to &quot;第 8 章&quot;">​</a></h1><h2 id="_1-7" tabindex="-1">1 <a class="header-anchor" href="#_1-7" aria-label="Permalink to &quot;1&quot;">​</a></h2><blockquote><p>典型的软件漏洞包括哪些类型？针对每种类型的漏洞，有哪些防护措施？</p></blockquote><ol><li>缓冲区溢出漏洞 <ul><li>不要禁用溢出保护</li><li>在编程时，不选C，C++等缺少内存管理支持的语言而选择java、perl等语言</li><li>在内存中随机排列程序的组件，从而使攻击者难以识别组件地址并利用特定组件</li><li>在创建代码时正确分配缓冲区空间、限制输入数据的长度</li></ul></li><li>非法输入漏洞 <ul><li>对所有用户采取“零信任”原则，即假设所有用户都有可能损害系统，因此要对其进行验证</li><li>要在服务端进行验证</li><li>可使用白名单以明确可接受的输入格式和内容</li><li>在验证输入时，需要对输入的长度、类型、语法和逻辑性进行验证。</li></ul></li><li>信息泄露漏洞 <ul><li>在设计程序体系结构时应该将敏感信息包含在具有明确信任边界的区域中，使用访问控制来保护和限制安全区域与端点之间的连接</li><li>验证错误消息和用户警告中是否包含不必要的信息</li><li>限制来自URL和通信标头的敏感信息，例如路径名或API密钥。</li></ul></li><li>权限漏洞 <ul><li>在与软件和系统交互的所有用户和服务中应用最小权限原则，使用访问控制来限制用户和实体的功能，使用户和服务只能访问自己所需要的那些资源</li><li>将高权限用户分成多个角色，分离有助于限制“高级用户”，并降低攻击者滥用访问权限的能力</li><li>应用多因素身份验证方法来防止攻击者轻易获取访问权限</li></ul></li></ol><h2 id="_2-4" tabindex="-1">2 <a class="header-anchor" href="#_2-4" aria-label="Permalink to &quot;2&quot;">​</a></h2><blockquote><p>软件漏洞防治的流程是什么？</p></blockquote><p><strong>需求与设计阶段</strong>：分析安全需求、进行威胁建模、设计安全架构。</p><p><strong>编码阶段</strong>：遵循安全编码规范，进行输入验证、错误处理和日志记录。</p><p><strong>静态代码分析</strong>：使用静态分析工具检测代码中的安全漏洞。</p><p><strong>动态分析与安全测试</strong>：进行漏洞扫描、渗透测试，确保系统运行时的安全性。</p><p><strong>漏洞修复与补丁管理</strong>：修复漏洞并发布补丁，进行回归测试。</p><p><strong>发布与部署</strong>：确保安全配置、加密和认证，严格访问控制。</p><p><strong>持续监控与响应</strong>：监控运行状态，及时发现并响应安全事件。</p><p><strong>定期审计与更新</strong>：定期进行安全审计，更新和优化系统安全。</p><p><strong>漏洞管理和回顾</strong>：完善漏洞管理流程，进行复盘和改进。</p><h2 id="_3-3" tabindex="-1">3 <a class="header-anchor" href="#_3-3" aria-label="Permalink to &quot;3&quot;">​</a></h2><blockquote><p>漏洞挖掘技术可以分为哪几种？对比它们的技术特点和应用场景。</p></blockquote><ol><li><p>基于源码的静态漏洞分析</p><p><strong>技术特点</strong>：</p><ul><li>分析源代码，提前发现漏洞</li><li>自动化程度高，覆盖全面</li><li>无法检测运行时行为（如内存泄漏）</li></ul><p><strong>应用场景</strong>：</p><ul><li>开发阶段漏洞检测、代码审计</li><li>确保代码符合安全规范</li><li>漏洞回归检测</li></ul></li><li><p>基于二进制码的静态漏洞分析</p><p><strong>技术特点</strong>：</p><ul><li>分析编译后的二进制文件，无需源码</li><li>反汇编与反编译，发现静态漏洞</li><li>无法检测动态行为（如内存泄漏）</li></ul><p><strong>应用场景</strong>：</p><ul><li>闭源软件分析、嵌入式系统安全</li><li>恶意软件逆向、第三方库评估</li></ul></li><li><p>基于二进制码的动态漏洞分析</p><p><strong>技术特点</strong>：</p><ul><li>在程序执行时监控行为，捕获运行时漏洞</li><li>能模拟攻击，实时发现漏洞</li><li>依赖特定的输入和执行环境</li></ul><p><strong>应用场景</strong>：</p><ul><li>渗透测试、运行时漏洞检测</li><li>漏洞验证与修复检查</li></ul></li></ol><h2 id="_10" tabindex="-1">10 <a class="header-anchor" href="#_10" aria-label="Permalink to &quot;10&quot;">​</a></h2><blockquote><p>基于二进制码的静态漏洞分析方法包括哪几种？对比它们的技术特点和应用场景。</p></blockquote><ol><li><p>基于模式的静态分析技术</p><p><strong>技术特点</strong>：</p><ul><li>通过匹配已知漏洞模式（签名）识别漏洞。</li><li>快速扫描二进制文件，检测已知漏洞类型。</li><li>误报较多，只能发现已知漏洞。</li></ul><p><strong>应用场景</strong>：</p><ul><li>快速检测已知漏洞，特别是恶意软件分析。</li><li>闭源软件的漏洞扫描，批量检查。</li><li>大规模的自动化漏洞检测。</li></ul></li><li><p>基于二进制代码对比的静态分析技术</p><p><strong>技术特点</strong>：</p><ul><li>通过对比不同版本的二进制文件，发现修改引入的漏洞。</li><li>分析二进制文件的差异，检测潜在安全问题。</li><li>需要多个二进制文件，复杂度较高。</li></ul><p><strong>应用场景</strong>：</p><ul><li>检查软件版本更新中的漏洞，补丁审计。</li><li>恶意代码检测，比较原始和修改后的二进制文件。</li><li>漏洞回归测试和安全性验证。</li></ul></li></ol><h1 id="第-9-章" tabindex="-1">第 9 章 <a class="header-anchor" href="#第-9-章" aria-label="Permalink to &quot;第 9 章&quot;">​</a></h1><h2 id="_1-8" tabindex="-1">1 <a class="header-anchor" href="#_1-8" aria-label="Permalink to &quot;1&quot;">​</a></h2><blockquote><p>结合你自己的理解，谈谈什么是恶意代码？</p></blockquote><p>恶意代码是指以破坏计算机系统的安全性、可用性、完整性和正常使用为目的代码程序，通过计算机网络和存储设备等媒介进行传播，可以在未授权的情况下通过本地运行或者远程执行以达到不正当的目的。</p><h2 id="_7-2" tabindex="-1">7 <a class="header-anchor" href="#_7-2" aria-label="Permalink to &quot;7&quot;">​</a></h2><blockquote><p>目前很多恶意软件兼具多种不同类型恶意代码的特点，恶意代码类别间的界限越来约模糊，其原因是什么？</p></blockquote><p><strong>技术进步</strong>：攻击者技术水平提高，能够将多种恶意行为（如病毒、木马、勒索等）集成在同一恶意软件中。</p><p><strong>攻击方式多样化</strong>：现代攻击常涉及多个阶段，结合不同恶意代码（如利用木马进行勒索或信息窃取）。</p><p><strong>模块化设计</strong>：恶意软件采用模块化结构，便于集成不同功能，增加复杂性和隐蔽性。</p><p><strong>复杂攻击链</strong>：攻击者通过多步骤、多层次的攻击实现目标，导致恶意代码具备多种特性。</p><p><strong>跨平台性</strong>：现代恶意软件通常支持多平台，表现出多种恶意行为，进一步模糊分类。</p><h2 id="_8-1" tabindex="-1">8 <a class="header-anchor" href="#_8-1" aria-label="Permalink to &quot;8&quot;">​</a></h2><blockquote><p>针对恶意软件行为日益泛化、界限日益模糊的缺点，应该如何科学地对恶意软件进行分类和防治？</p></blockquote><p>分类：</p><ol><li><strong>行为分类</strong>：根据恶意软件行为分类，如病毒、蠕虫（自我复制）、木马、间谍软件（信息窃取）、勒索软件（破坏）等。</li><li><strong>传播方式分类</strong>：通过网络传播、文件附件传播、漏洞利用传播等。</li><li><strong>技术分类</strong>：传统恶意软件、APT攻击、零日漏洞利用等。</li><li><strong>影响分类</strong>：直接破坏（勒索软件）、间接破坏（广告软件、间谍软件）等。</li><li><strong>目标分类</strong>：个人攻击、企业攻击、基础设施攻击等。</li></ol><p>防治：</p><ol><li><strong>多层防御</strong>：结合防火墙、IDS/IPS、操作系统安全、数据加密等技术，形成多重防护。</li><li><strong>AI和机器学习</strong>：利用行为分析和深度学习检测未知恶意软件，提升检测能力。</li><li><strong>动态分析与沙箱技术</strong>：通过隔离可疑程序分析其行为，识别潜在威胁。</li><li><strong>终端检测与响应（EDR）</strong>：实时监控终端设备，及时响应和处理安全事件。</li><li><strong>补丁管理</strong>：及时更新系统和软件，修补漏洞，避免被利用。</li><li><strong>用户教育</strong>：提高员工的安全意识，防止社交工程学攻击。</li><li><strong>备份与应急响应</strong>：定期备份关键数据，确保数据恢复能力，快速响应攻击事件。</li></ol><h2 id="_11-1" tabindex="-1">11 <a class="header-anchor" href="#_11-1" aria-label="Permalink to &quot;11&quot;">​</a></h2><blockquote><p>恶意代码的发展有什么特点？</p></blockquote><p>随着网络和软件技术的快速发展及其越来越广泛的应用，恶意代码在制作、传播、攻击和对抗等方面也在不断演讲，恶意代码的样本总量、类型数量、复杂程度、攻击和脱逃能力都在不断攀升，恶意代码的危害程度和范围也越来越大。</p><h1 id="第-10-章" tabindex="-1">第 10 章 <a class="header-anchor" href="#第-10-章" aria-label="Permalink to &quot;第 10 章&quot;">​</a></h1><h2 id="_2-5" tabindex="-1">2 <a class="header-anchor" href="#_2-5" aria-label="Permalink to &quot;2&quot;">​</a></h2><blockquote><p>PE文件格式包括哪几部分？</p></blockquote><p>DOS部分、PE文件头、节表和节</p><h2 id="_4-3" tabindex="-1">4 <a class="header-anchor" href="#_4-3" aria-label="Permalink to &quot;4&quot;">​</a></h2><blockquote><p>可执行文件生成主要包括哪几个步骤？</p></blockquote><ol><li>预处理</li><li>编译</li><li>汇编</li><li>连接</li></ol><h2 id="_6-1" tabindex="-1">6 <a class="header-anchor" href="#_6-1" aria-label="Permalink to &quot;6&quot;">​</a></h2><blockquote><p>系统引导主要包含哪几个阶段？</p></blockquote><p>预引导阶段、引导阶段、载入内核阶段、初始化内核阶段、登录阶段。</p><h2 id="_7-3" tabindex="-1">7 <a class="header-anchor" href="#_7-3" aria-label="Permalink to &quot;7&quot;">​</a></h2><blockquote><p>简述文件加载运行的过程？</p></blockquote><ol><li>用户请求执行</li><li>文件访问</li><li>加载到内存</li><li>运行程序</li></ol><h1 id="第-11-章" tabindex="-1">第 11 章 <a class="header-anchor" href="#第-11-章" aria-label="Permalink to &quot;第 11 章&quot;">​</a></h1><h2 id="_1-9" tabindex="-1">1 <a class="header-anchor" href="#_1-9" aria-label="Permalink to &quot;1&quot;">​</a></h2><blockquote><p>什么是静态逆向分析技术？</p></blockquote><p>静态逆向分析技术是指通过对程序或文件的静态分析，即不运行该程序或文件的情况下，分析其结构、代码、行为等，以理解其功能、发现漏洞、检测恶意软件或破解保护机制的技术。静态逆向分析主要通过查看程序的二进制文件、源代码（如果有）、编译后的代码、符号表、资源等信息来进行分析。</p><h2 id="_3-4" tabindex="-1">3 <a class="header-anchor" href="#_3-4" aria-label="Permalink to &quot;3&quot;">​</a></h2><blockquote><p>什么是动态逆向分析技术？</p></blockquote><p>动态逆向分析技术是指通过执行程序并观察其运行时行为来分析程序的结构、功能和潜在问题的技术。与静态逆向分析不同，动态分析不依赖于对代码的静态查看，而是通过在受控环境下运行程序，捕捉其执行时的动态行为（如内存操作、系统调用、网络通信等）来获得信息。动态逆向分析可以帮助理解程序如何在实际环境中运行，并揭示静态分析难以发现的行为。</p><h2 id="_6-2" tabindex="-1">6 <a class="header-anchor" href="#_6-2" aria-label="Permalink to &quot;6&quot;">​</a></h2><blockquote><p>试比较静态分析技术与动态逆向分析技术的特点。</p></blockquote><ul><li><strong>静态分析</strong>：不执行程序，分析代码和结构，适合漏洞挖掘和恶意软件分析。 <ul><li><strong>优点</strong>：安全、无需执行程序。</li><li><strong>缺点</strong>：无法捕捉运行时行为，无法分析加密或混淆的代码。</li></ul></li><li><strong>动态分析</strong>：执行程序并监控其运行行为，适合检测恶意活动和运行时漏洞。 <ul><li><strong>优点</strong>：能捕捉真实的程序行为，发现动态恶意行为。</li><li><strong>缺点</strong>：需要执行程序，存在安全风险，依赖特定环境。</li></ul></li></ul><p>简而言之，<strong>静态分析</strong>看代码，<strong>动态分析</strong>看执行。</p><h2 id="_10-1" tabindex="-1">10 <a class="header-anchor" href="#_10-1" aria-label="Permalink to &quot;10&quot;">​</a></h2><blockquote><p>为了对抗反病毒软件的检测，恶意软件常用的自我保护措施有哪些？</p></blockquote><ol><li><p>代码混淆</p><ul><li><p><strong>目的</strong>：通过改变程序的外观，使得分析者难以理解其实际功能。</p></li><li><p><strong>方式</strong>：使用难以理解的变量名、函数名，或将代码结构故意改变，使其难以直接反编译。</p></li></ul></li><li><p>代码加壳</p><ul><li><p><strong>目的</strong>：使恶意代码在执行前被加密或压缩，只有在运行时才能解开。</p></li><li><p><strong>方式</strong>：通过加壳技术将恶意代码隐藏在外壳程序中，反病毒软件无法直接扫描壳中的恶意部分，只有在程序解开壳后才能检测。</p></li></ul></li><li><p>反调试</p><ul><li><p><strong>目的</strong>：阻止调试器的使用，避免程序被分析。</p></li><li><p><strong>方式</strong>：恶意软件通过检测调试器是否存在，或者使用反调试技术，如检查特定的调试API、修改程序流程等，防止被调试器捕捉和分析。</p></li></ul></li><li><p>反沙箱</p><ul><li><p><strong>目的</strong>：检测是否在沙箱或虚拟机环境中运行，避免在分析环境中暴露恶意行为。</p></li><li><p><strong>方式</strong>：通过检测虚拟机、沙箱的特征（如硬件指纹、系统进程名称等），恶意软件可以识别虚拟环境并停止恶意活动或做出不同的行为。</p></li></ul></li><li><p>自我删除</p><ul><li><p><strong>目的</strong>：在被检测到时，立即删除或隐藏自身以防止被捕获。</p></li><li><p><strong>方式</strong>：在检测到反病毒软件或分析工具时，恶意软件会自我销毁或隐藏自身的文件，避免被反病毒软件删除。</p></li></ul></li><li><p>权限提升</p><ul><li><p><strong>目的</strong>：使恶意软件获得更高的权限，以绕过检测和限制。</p></li><li><p><strong>方式</strong>：通过漏洞利用或社会工程学手段，提升自身权限，从而禁用或绕过反病毒软件和防火墙。</p></li></ul></li></ol><h1 id="第-12-章" tabindex="-1">第 12 章 <a class="header-anchor" href="#第-12-章" aria-label="Permalink to &quot;第 12 章&quot;">​</a></h1><h2 id="_1-10" tabindex="-1">1 <a class="header-anchor" href="#_1-10" aria-label="Permalink to &quot;1&quot;">​</a></h2><blockquote><p>列出与软件相关的三种主要知识产权，并分别说明其内容。</p></blockquote><ol><li>专利权 <ul><li>专利权是国家知识产权主管部门给与一项发明拥有者一个包含有效期限的许可证明。</li></ul></li><li>版权 <ul><li>版权，也称著作权，是保护创造出一个有形（或无形）作品的个人的权利；版权也可以转为一个组织所拥有。该组织向该创作者支付版权费，从而获得该作品的所有权。</li></ul></li><li>商标权 <ul><li>商标是与公司、产品或观念联系在一起的、具有显著特征的名称或标记，表现为与企业有关联的文字、图形或其组合。</li></ul></li></ol><h2 id="_2-6" tabindex="-1">2 <a class="header-anchor" href="#_2-6" aria-label="Permalink to &quot;2&quot;">​</a></h2><blockquote><p>列举三种主要的开源软件许可证协议，并说明其异同。</p></blockquote><ol><li><strong>MIT 许可证</strong></li></ol><ul><li><p>特点</p><ul><li>非常宽松，允许用户使用、复制、修改、合并、发布、分发、再授权和销售软件。</li><li>唯一要求是在分发时必须包含原始许可证和版权声明。</li></ul></li><li><p><strong>主要要求</strong>：只需保留版权声明和许可证，几乎没有其他限制。</p></li><li><p><strong>应用例子</strong>：<strong>jQuery</strong>、<strong>Rails</strong>、<strong>Node.js</strong>。</p></li><li><p><strong>适用场景</strong>：适用于希望最大化自由使用的项目，特别是开发者希望广泛传播其代码时。</p></li></ul><ol start="2"><li><strong>BSD 许可证</strong></li></ol><ul><li>特点 <ul><li>传统的 BSD 许可证有几种变体，最常见的是 <strong>2-Clause BSD</strong> 和 <strong>3-Clause BSD</strong> 许可证。</li><li><strong>2-Clause BSD</strong>：允许软件自由使用、修改和分发，仅要求保留版权声明和免责声明。</li><li><strong>3-Clause BSD</strong>：与2-Clause类似，但增加了“禁止使用组织名或贡献者名来推广衍生产品”的条款。</li></ul></li><li><strong>主要要求</strong>：必须保留原始版权声明和免责声明，3-Clause BSD 增加了禁止使用名称条款。</li><li><strong>应用例子</strong>：<strong>FreeBSD</strong>、<strong>OpenBSD</strong>、<strong>NetBSD</strong>（这些都是 BSD 操作系统的核心）。</li><li><strong>适用场景</strong>：适合希望对外发布代码并允许商业化使用的项目，尤其是希望最大化的代码传播并保持一定的品牌控制。</li></ul><ol start="3"><li><strong>Apache 许可证</strong></li></ol><ul><li>特点 <ul><li>与 MIT 和 BSD 相似，允许自由使用、修改和分发代码，但<strong>附加专利条款</strong>，即贡献者同意不对使用该代码的用户提起专利诉讼。</li><li>强调专利保护，并且要求在分发代码时附带修改记录。</li><li>提供<strong>商标使用限制</strong>，不允许未经许可使用项目的商标。</li></ul></li><li><strong>主要要求</strong>：要求在分发代码时附带许可证和修改记录，包含专利条款和商标使用限制。</li><li><strong>应用例子</strong>：<strong>Apache Hadoop</strong>、<strong>Android</strong>、<strong>Apache HTTP Server</strong>。</li><li><strong>适用场景</strong>：适合需要专利保护的企业和社区，特别是在需要明确声明修改记录和保护商标的场景。</li></ul><h2 id="_5-3" tabindex="-1">5 <a class="header-anchor" href="#_5-3" aria-label="Permalink to &quot;5&quot;">​</a></h2><blockquote><p>举例说明三种常见的软件侵权问题。</p></blockquote><ol><li>未经软件著作权人许可，发表或者登记其软件。</li><li>将他人软件作为自己的软件发表或者登记。</li><li>在他人软件上署名或者更改他人软件上的署名。</li></ol><h1 id="第-13-章" tabindex="-1">第 13 章 <a class="header-anchor" href="#第-13-章" aria-label="Permalink to &quot;第 13 章&quot;">​</a></h1><h2 id="_1-11" tabindex="-1">1 <a class="header-anchor" href="#_1-11" aria-label="Permalink to &quot;1&quot;">​</a></h2><blockquote><p>什么是软件权益？软件权益包括哪些内容？</p></blockquote><p>软件权益主要体现为软件知识产权，包括软件著作权、软件专利权、软件商业秘密专有权和商标等。</p><h2 id="_3-5" tabindex="-1">3 <a class="header-anchor" href="#_3-5" aria-label="Permalink to &quot;3&quot;">​</a></h2><blockquote><p>试举例说明两种基于硬件的用户合法性验证技术。</p></blockquote><ol><li><p>基于光盘等介质的验证</p><ul><li><p>用户需插入授权的光盘、USB闪存盘或硬盘等存储介质，软件或硬件通过读取介质中的授权文件或密钥进行验证，确保用户拥有合法授权。</p><p><strong>示例</strong>：某CAD软件需要插入授权的光盘才能启动，未插入光盘则无法使用软件。</p></li></ul></li><li><p>加密锁验证</p><ul><li><p>用户通过插入硬件加密锁（如USB加密锁），软件通过读取锁内的唯一密钥进行验证，确保用户合法使用软件。</p><p><strong>示例</strong>：专业音频制作软件需要插入USB加密锁才能启用，缺少加密锁则无法运行软件。</p></li></ul></li></ol><h2 id="_4-4" tabindex="-1">4 <a class="header-anchor" href="#_4-4" aria-label="Permalink to &quot;4&quot;">​</a></h2><blockquote><p>有哪些基于软件的用户合法性验证技术？分析这些技术的特点。</p></blockquote><ol><li>基于静态口令的注册验证 <ul><li>用户设置一个固定密码，登录时通过输入该密码进行验证。</li><li>简单易用，但安全性较低，容易被猜测或破解。</li></ul></li><li>基于动态口令的登录验证 <ul><li>使用一次性动态密码（OTP），通常通过短信、电子邮件或应用生成，每次登录时使用不同的密码。</li><li>比静态口令更安全，有效防止密码泄露，但需要额外的设备或通信方式。</li></ul></li><li>基于序列号的注册验证 <ul><li>软件通过唯一的序列号来验证用户的合法性，序列号通常在软件安装或购买时提供。</li><li>实现简单，但容易被复制或破解，安全性较低。</li></ul></li><li>基于KeyFile的注册验证 <ul><li>使用一个特定的文件（KeyFile），包含加密密钥或授权信息，进行用户验证。</li><li>较为安全，密钥文件不易复制，但如果文件丢失，用户将无法使用软件。</li></ul></li></ol>`,212),e=[n];function o(h,p,r,k,d,u){return s(),l("div",null,e)}const E=i(t,[["render",o]]);export{c as __pageData,E as default};
