import{_ as a,c as s,o as l,a6 as n}from"./chunks/framework.DkFL-jqo.js";const I=JSON.parse('{"title":"串指令的通用规则","description":"","frontmatter":{},"headers":[],"relativePath":"八股/汇编/串指令.md","filePath":"八股/汇编/串指令.md"}'),i={name:"八股/汇编/串指令.md"},p=n(`<h1 id="串指令的通用规则" tabindex="-1">串指令的通用规则 <a class="header-anchor" href="#串指令的通用规则" aria-label="Permalink to &quot;串指令的通用规则&quot;">​</a></h1><ol><li><p>串操作指令一定会涉及存储器操作数：</p><ul><li>默认源串由DS：[SI]指出(DS可用段前缀指令改变)；</li><li>默认目的串由ES：[DI]指出(不允许使用段超越前缀)。</li></ul></li><li><p>如果涉及寄存器操作数：只能位于累加器 AL/AX/EAX中。</p></li><li><p>任何一条串操作指令执行结束时，SI/DI 会自动增/减：1或者2或者4！！！</p></li><li><p>增加或者减少由DF标志位决定：若DF=0则加， 若DF=1则减</p></li><li><p>增减的数值：由串操作指令本身指定的数据 长度(字节数)决定</p></li><li><p>常常使用重复前缀</p><ul><li><code>REP ； REPE／REPZ； REPNE／REPNZ。</code></li><li>重复前缀的功能：与LOOP指令类似，重复 操作的次数由CX决定，执行时需判断(CX)是 否非0</li><li>使用重复前缀时，应该把需要处理的数据个数(不是字节数！)预先存放在CX中， 数据可以是字节型、字型或者双字型</li><li>REPE／REPZ(相等重复前缀)：当(CX≠0)且 ZF＝1时，串指令重复执行；一旦条件不满足，重复就停止。 <ul><li>与LOOPE/LOOPZ 类似、REPE／REPZ常常用于比较两个字符串/数组/文件是否相同</li></ul></li><li>REPNE/REPNZ(不等重复前缀)：当(CX≠0) 且ZF＝0时，串指令重复执行。 <ul><li>与LOOPNE/LOOPNZ 类似、REPNE／ REPNZ常常用于从一个字符串或数组或文件 中搜索是否存在一个数据等于给定的关键字</li></ul></li></ul></li></ol><h1 id="串传送指令movs" tabindex="-1">串传送指令MOVS <a class="header-anchor" href="#串传送指令movs" aria-label="Permalink to &quot;串传送指令MOVS&quot;">​</a></h1><ul><li><p>MOVSB ；字节传送</p></li><li><p>MOVSW ；字传送</p></li><li><p>MOVSD ；双字传送</p></li><li><p>显式<code>MOVS OPRD1，OPRD2</code></p></li><li><p>功能：将以DS：[ SI ]为指针的源串中存储单元中的 一个字节(或字或双字) 型的数据传送至以ES：[ DI ] 寻址的目的地址中去，并自动修改指针SI、DI ，使 之指向下一个字节(或字或双字)存储单元。</p></li><li><p>(DS：[SI])→ES：[DI]。</p></li><li><p>当DF=0时，(SI)和(DI)增量。当DF=1时，(SI)和(DI)减量。</p></li><li><p>该指令可以使用前缀REP。功能：当(CX)≠0 时，执行一次串指令，(CX)－1 → CX ，直到 (CX)=0时循环结束</p></li></ul><h2 id="eg-数据块传送" tabindex="-1">eg-数据块传送 <a class="header-anchor" href="#eg-数据块传送" aria-label="Permalink to &quot;eg-数据块传送&quot;">​</a></h2><p>将数据段(由DS寻址段基址)中SRC单元开始 的100个字节，依次传送到：附加段(由ES寻址段基址)中DST开始的内存区域中。</p><p>设数据段： SRC DB ×，…，× • ;100个字节型数据 • 设附加段： DST DB 100 DUP(?)</p><ol><li><p>用MOV指令编程</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>LEA DI,SRC</span></span>
<span class="line"><span>LEA SI,DST</span></span>
<span class="line"><span>MOV CX,100</span></span>
<span class="line"><span>NEXT:</span></span>
<span class="line"><span>	MOV AL,[SI]</span></span>
<span class="line"><span>	MOV ES:[DI],AL</span></span>
<span class="line"><span>	INC SI</span></span>
<span class="line"><span>	INC DI</span></span>
<span class="line"><span>	LOOP NEXT</span></span></code></pre></div></li><li><p>用MOVSB指令编程</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>LEA DI,SRC</span></span>
<span class="line"><span>LEA SI,DST</span></span>
<span class="line"><span>MOV CX,100</span></span>
<span class="line"><span>LAST:</span></span>
<span class="line"><span>	MOVSB ;串指令：SI、DI自动变。</span></span>
<span class="line"><span>	LOOP LAST</span></span></code></pre></div></li><li><p>用REP MOVSB指令编程</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>LEA DI,SRC</span></span>
<span class="line"><span>LEA SI,DST</span></span>
<span class="line"><span>MOV CX,100</span></span>
<span class="line"><span>CLD ;使DF=0</span></span>
<span class="line"><span>REP MOVSB</span></span></code></pre></div></li><li><p>用REP MOVSD指令编程</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>LEA DI,SRC</span></span>
<span class="line"><span>LEA SI,DST</span></span>
<span class="line"><span>MOV CX,25  ;充分利用字长，减少了：循环次数</span></span>
<span class="line"><span>CLD ;使DF=0</span></span>
<span class="line"><span>REP MOVSD</span></span></code></pre></div><h1 id="串装入指令" tabindex="-1">串装入指令 <a class="header-anchor" href="#串装入指令" aria-label="Permalink to &quot;串装入指令&quot;">​</a></h1></li></ol><ul><li>LODSB ；DS:[SI]中的一个字节送AL</li><li>LODSW ；DS:[SI]中的一个字送AX</li><li>LODSD ；DS:[SI]中的一个双字送EAX</li><li>显式格式：LODS SRC</li><li>将通过DS：[SI]寻址的源串中一个字节(或字或双字) 型数据装入到寄存器AL/AX/EAX中，且根据DF的值，自动修改SI的值，以指向下一个要装入的字节或字或双字。</li><li>字节操作：(DS:[SI])→AL 字操作：(DS:[SI])→AX。</li><li>修改指针SI，使它指向串中的下一个元素。当DF=0时， (SI)增量。当DF=1时，(SI)减量。(注意：此时DI不变。)</li><li>串装入指令如果带前缀REP无意义</li></ul><h1 id="串存储指令" tabindex="-1">串存储指令 <a class="header-anchor" href="#串存储指令" aria-label="Permalink to &quot;串存储指令&quot;">​</a></h1><ul><li>STOSB ；把AL→ ES:[ DI]的1个单元</li><li>STOSW ；把AX→ ES:[ DI]的2个单元</li><li>STOSD ；把EAX→ ES:[ DI]的4个单元</li><li>显式格式：STOS DST</li><li>功能：将寄存器AL/AX/EAX中的一个字节(或字或 双字)数据存储到由ES：[DI]寻址的附加段中去，并且根据DF的值来修改DI的值，以指向下一个要装入 的字节或字或双字数据。</li><li>字节操作：(AL)→ ES：[DI]，字操作：(AX)→ ES：[DI]；</li><li>修改指针DI，使之指向串中的下一个元素。当 DF=0时，(DI)增量。当DF=1时，(DI)减量。</li><li>该指令可以带前缀REP。重复前缀的格式<code>REP STOSB/STOSW/STOSD</code></li><li>功能是: <ul><li>对一片连续的存储空间赋予一个相同的数值 (来自于AL/AX/EAX)；</li><li>通常是对一片连续的存储空间执行清0操作。</li></ul></li></ul><h2 id="eg-用lodsb-stosb指令编程" tabindex="-1">eg-[用LODSB，STOSB指令编程] <a class="header-anchor" href="#eg-用lodsb-stosb指令编程" aria-label="Permalink to &quot;eg-[用LODSB，STOSB指令编程]&quot;">​</a></h2><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>LEA    SI，SRC</span></span>
<span class="line"><span>LEA    DI，DST</span></span>
<span class="line"><span>MOV    CX，100</span></span>
<span class="line"><span>CLD ;使DF=0</span></span>
<span class="line"><span>LAST：LODSB</span></span>
<span class="line"><span>	 STOSB</span></span>
<span class="line"><span>LOOP LAST</span></span></code></pre></div><h1 id="串比较指令cmp" tabindex="-1">串比较指令CMP <a class="header-anchor" href="#串比较指令cmp" aria-label="Permalink to &quot;串比较指令CMP&quot;">​</a></h1><ul><li>CMPSB ；字节比较</li><li>CMPSW ；字比较</li><li>CMPSD ；双字比较</li><li>CMPS OPRD1源，OPRD2目的；</li><li>(DS：[SI])－(ES：[DI])。</li><li>修改串指针，使之指向串中的下一个元素。 当DF=0时，(SI)和(DI)增量。当DF=1时，(SI) 和(DI)减量。</li><li>串比较命令是将数据段DS：[SI]指针 指出的一个字节或字或双字型数据与附加段 ES：[DI]指出的字节或字或双字型数据进行 比较(相减)，根据比较结果设置标志位寄存器， 而结果不保存。常用于内存区之间的数据、 字符等的比较。</li></ul>`,15),e=[p];function t(S,c,o,D,d,h){return l(),s("div",null,e)}const u=a(i,[["render",t]]);export{I as __pageData,u as default};
