import{_ as a,c as l,o as i,a6 as e}from"./chunks/framework.DkFL-jqo.js";const q=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"八股/汇编/前置知识.md","filePath":"八股/汇编/前置知识.md"}'),o={name:"八股/汇编/前置知识.md"},p=e('<h2 id="进制的书写规则" tabindex="-1">进制的书写规则 <a class="header-anchor" href="#进制的书写规则" aria-label="Permalink to &quot;进制的书写规则&quot;">​</a></h2><ul><li><p>二进制数的100写成100 B</p></li><li><p>八进制数的100写成100 O</p></li><li><p>十六进制数100写成100 H</p></li><li><blockquote><p>注意：如果以字母A~F开始的16进制数，前面加0,以避免和符号名发 生混淆。如(F5) 16 =0F5H。</p></blockquote></li><li><p>十进制数100可以写为100D，省略后缀字母时默认为十进制数</p></li></ul><h2 id="求补运算" tabindex="-1">求补运算 <a class="header-anchor" href="#求补运算" aria-label="Permalink to &quot;求补运算&quot;">​</a></h2><ul><li><p>正数</p><ul><li>原码、反码、补码相同</li></ul></li><li><p>负数</p><ul><li><p>法一：反码+1</p><ul><li><p>反码为：第一位符号位不变，后面相反</p></li><li><p>eg: [-46]补码</p><p>[-46]原码 = 1 0 1 0 1 1 1 0</p><p>[-46]反码 = 1 1 0 1 0 0 0 1</p><p>[-46]补码 = 1 1 0 1 0 0 1 0 = D2H</p></li></ul></li><li><p>法二：从低位开始向高位观察，遇见第一个1，则 将包含第一个1在内的所有低位数值0保持不变，将包括符号位在内的所有高位取反。（求补运算）</p><ul><li><p>eg: [-46]补码</p><p>[46]</p><p>0 0 1 0 1 1 1 0</p><p>1 1 0 1 0 0 1 0 = D2H</p></li><li><blockquote><p>“求补运算”适用于：</p><p>1.求一个负数真值的补码：对正数补码执行求 补运算；</p><p>2.求一个负数补码的真值；</p><p>3.把补码减法变成加法：减去一个数，等于加 上一个数的相反数，从而可以把减法转换成 加法。这个过程实际上就是求：一个补码的 真值的相反数的补码</p></blockquote></li></ul></li></ul></li></ul><h2 id="补码运算" tabindex="-1">补码运算 <a class="header-anchor" href="#补码运算" aria-label="Permalink to &quot;补码运算&quot;">​</a></h2><blockquote><p>补码表示法的运算特点是：将<em>符号位</em>视为数 据位直接参与运算、从而简化了加减运算的 硬件电路；</p><p>由于加减运算最为频繁，因此现代计算机中 普遍使用补码作为有符号数的表示方式</p></blockquote><ol><li><ul><li>公式1：[X+Y]补=[X]补+[Y]补。</li><li>公式2：[X–Y]补=[X+(–Y)]补=[X]补+[–Y]补</li></ul></li><li><p>参加运算的两个操作数均用补码表示；</p></li><li><p>补码减法可用加法替换；</p></li><li><p>运算结果为补码；</p></li><li><p>进位值CF无论是0或1：对补码运算结果(对/ 错)均无影响！！！</p></li><li><p>当运算结果超出字长能够表示的合法范围时， 结果就不再正确。此时称为溢出！</p></li><li><p>为了让程序员获知有符号数补码运算过程中 的溢出信息，现代CPU中普遍设置了一个专 门的硬件触发器：溢出标志位触发器：OF！</p></li></ol><h2 id="标志位" tabindex="-1">标志位 <a class="header-anchor" href="#标志位" aria-label="Permalink to &quot;标志位&quot;">​</a></h2><h3 id="进位标志cf" tabindex="-1">进位标志CF <a class="header-anchor" href="#进位标志cf" aria-label="Permalink to &quot;进位标志CF&quot;">​</a></h3><ol><li>对于有符号数（补码）的运算，CF中的进位值无论 是0还是1，都没有意义，即：进位值CF不能统计在 运算结果之中。</li></ol><h3 id="溢出标志of" tabindex="-1">溢出标志OF <a class="header-anchor" href="#溢出标志of" aria-label="Permalink to &quot;溢出标志OF&quot;">​</a></h3><blockquote><p>溢出：当两个二进制数(有/无符号数)进行运算时， 若运算结果超出一个机器数的表示范围时(运算装置 的容量有限)，就不能正确表示数了，此时称为溢出。</p></blockquote><ol><li>对于无符号数的运算，OF中的值无论是0还是1，都没有意义。</li><li>有符号数(补码)运算中考查OF才有意义</li></ol><h2 id="浮点数" tabindex="-1">浮点数 <a class="header-anchor" href="#浮点数" aria-label="Permalink to &quot;浮点数&quot;">​</a></h2><h3 id="定义" tabindex="-1">定义 <a class="header-anchor" href="#定义" aria-label="Permalink to &quot;定义&quot;">​</a></h3><ul><li>浮点数是小数点可以左右移动的数。</li></ul><p>例如：45.3125 = +101101.0101 = +0.1011010101 × 2+6 • = +1011010101 × 2-4 •</p><p>即可以写成二进制格式：±S×2±J •</p><p>其中：+/-J为阶码(Exponenet)，表示小数点 位置；+/-S为尾数(Mantissa或者Significand)。</p><h3 id="规范化" tabindex="-1">规范化 <a class="header-anchor" href="#规范化" aria-label="Permalink to &quot;规范化&quot;">​</a></h3><ul><li><p>由于一个浮点数在机器中可以有多种表示，运算时 不方便，故对其进行规格化，使得表示方法唯一。 •</p></li><li><p>浮点数的规格化(Normalized)定义：一个规格化的 浮点数真值满足：</p></li></ul><p>1)尾数为纯小数，且小数点后第一位为1； • (2)阶码为整数。</p><p>例如:45.3125 的规格化数为：+0.1011010101×2+6 而不是+0.01011010101×2+7 也不是+101.1010101×2+</p><h2 id="bcd码" tabindex="-1">BCD码 <a class="header-anchor" href="#bcd码" aria-label="Permalink to &quot;BCD码&quot;">​</a></h2><h3 id="分类" tabindex="-1">分类 <a class="header-anchor" href="#分类" aria-label="Permalink to &quot;分类&quot;">​</a></h3><h4 id="压缩-组合bcd码" tabindex="-1">压缩/组合BCD码 <a class="header-anchor" href="#压缩-组合bcd码" aria-label="Permalink to &quot;压缩/组合BCD码&quot;">​</a></h4><p>每一位数采用4位二进制数来表示，则一个字节(包 含8位二进制数)可以表示两位十进制数。 •</p><p>例如：二进制数1000 1001B，采用压缩BCD码表示 为十进制数89D。 •</p><h4 id="非压缩-未组合bcd码" tabindex="-1">非压缩/未组合BCD码 <a class="header-anchor" href="#非压缩-未组合bcd码" aria-label="Permalink to &quot;非压缩/未组合BCD码&quot;">​</a></h4><p>每一位数采用8位二进制数来表示，即一个字节表示 一位十进制数。而且只用每个字节的低4位来表示 0～9，高4位为0。</p><p>例如：十进制数89D，采用非压缩BCD码表示为二 进制数必须使用2个字节，即：00001000B和 00001001B。</p>',31),t=[p];function r(h,c,n,d,u,s){return i(),l("div",null,t)}const _=a(o,[["render",r]]);export{q as __pageData,_ as default};
