import{_ as a,c as l,o as s,a6 as i}from"./chunks/framework.DkFL-jqo.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"八股/汇编/宏汇编.md","filePath":"八股/汇编/宏汇编.md"}'),p={name:"八股/汇编/宏汇编.md"},e=i(`<h2 id="汇编语言源程序到可执行文件的处理过程" tabindex="-1">汇编语言源程序到可执行文件的处理过程 <a class="header-anchor" href="#汇编语言源程序到可执行文件的处理过程" aria-label="Permalink to &quot;汇编语言源程序到可执行文件的处理过程&quot;">​</a></h2><p><img src="https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241224153647815.png" alt="image-20241224153647815"></p><ol><li>用编辑程序建立以ASM为后缀名的源文件。</li><li>用汇编程序(MASM.EXE)把源文件转换成OBJ 目标文件。</li><li>用连接程序(LINK.EXE)把目标文件转换成EXE 执行文件。</li><li>用DOS命令方式直接键入文件名，执行</li></ol><ul><li><p>asm或.c：</p></li><li><p>.obj：由机器指令代码构成</p></li><li><p>.exe或.com：一个完整的可执行文件</p></li></ul><h2 id="伪指令" tabindex="-1">伪指令 <a class="header-anchor" href="#伪指令" aria-label="Permalink to &quot;伪指令&quot;">​</a></h2><blockquote><p>伪指令，又称为伪语句，是汇编语言提供的指示性语言，为汇编程序和连接程序提供信息。</p><p>伪指令本身不占用内存单元，它们的功能是在汇编和连接时由相应的软件完成的</p></blockquote><h3 id="常量、变量与表达式" tabindex="-1">常量、变量与表达式 <a class="header-anchor" href="#常量、变量与表达式" aria-label="Permalink to &quot;常量、变量与表达式&quot;">​</a></h3><h4 id="常量" tabindex="-1">常量 <a class="header-anchor" href="#常量" aria-label="Permalink to &quot;常量&quot;">​</a></h4><blockquote><p>常量包括立即数、字符串常数和符号常数。</p></blockquote><ol><li><p>立即数</p><ul><li>如：125，125D，0A9H，10101010B， 11Q，－200。</li><li>立即数的数制用在数字之后添加后缀字母来表示， 后缀‘D’(或者缺省)表示十进制数，后缀‘H’表示 十六进制数，后缀‘B’表示二进制数，后缀‘Q’表 示八进制数。</li><li>立即数必须以数字开头，以字母A-F开头的十六进 制数必须加前缀数字0。</li><li>经过汇编之后，汇编程序将把各种进制表示的立即 数全部转换成等值的二进制数，负数转换成补码。</li></ul></li><li><p>字符/字符串常数</p><ul><li>用单引号括起来的字符串称为字符串常数。 如‘A’，‘A1B2C3’。</li><li>经过汇编之后，单引号中的每个字符将被转 换成相应的ASCII码，可以像使用立即数一样 使用它们。</li><li>eg: MOV AL，‘A’ ；寻址方式？AL = 41H</li></ul></li><li><p>符号常数</p><ul><li><p>符号常数用等值伪指令“EQU”或者等号伪指令 “＝”定义。</p></li><li><p>使用符号常数有利于程序调试，增加程序的可读性。</p></li><li><p>符号常数经过定义之后，实际上作为立即数使用。</p></li><li><p>eg:</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>PI   EQU   314</span></span>
<span class="line"><span>X = 100</span></span>
<span class="line"><span>MOV AX，PI    ;AX＝314</span></span>
<span class="line"><span>MOV DX，X     ;DX = 100</span></span></code></pre></div></li><li><p>符号常数不同于符号地址、是：立即数！(类似于 #define )</p></li><li><p>符号地址本质上是地址。</p></li><li><p>等值伪指令<code>EQU</code>和等号伪指令<code>=</code>的区别</p><ul><li>用EQU伪指令定义的符号常数，其值 在后续的程序中不能更改(能够避免程序员无意间重 复定义符号名) ；用等号伪指令定义的符号常数，在 后续的程序中可以重新定义，从而达到修改所定义 的符号常数的目的</li></ul></li></ul></li></ol><h3 id="符号地址" tabindex="-1">符号地址 <a class="header-anchor" href="#符号地址" aria-label="Permalink to &quot;符号地址&quot;">​</a></h3><ul><li>变量：代表内存操作数所在存储单元的存储地址， 或者说变量名就代表某个存储单元。</li><li>标号：代表指令所在存储单元的存储地址，它为转移指令提供了转移目标。</li><li>标号被定义在代码段，变量通常被定义在数据段、附加段或堆栈段。</li><li>由于标号和变量是用一串字符命名的，从这个意义上讲，变量和标号可以统称为符号地址。</li><li>理解：包括子程序名、段名皆是如此！</li><li>作为符号地址，具有共同的3个属性。 <ul><li>段属性。即标号或变量所在段的段基址， 用SEG运算符可以计算得到。</li><li>偏移属性。即标号或变量所代表的存储单 元，相对于段基址之间的偏移地址(或称有效地址)，用OFFSET运算符可以计算得到。</li><li>类型属性 <ul><li>变量的长度类型属性有字节型、字型、双字 型、四字型等等</li><li>用DB伪指令定义的变量，其所属的单元均为 字节型</li><li>用DW，DD，DQ伪指令定义的变量，其所属 的单元分别有字型、双字型和四字型属性</li></ul></li></ul></li></ul><h3 id="返回属性或数值的运算符" tabindex="-1">返回属性或数值的运算符 <a class="header-anchor" href="#返回属性或数值的运算符" aria-label="Permalink to &quot;返回属性或数值的运算符&quot;">​</a></h3><ol><li><p>SEG运算符</p><ul><li><p><code>SEG 段名</code></p></li><li><p>功能:计算某个逻辑段的段基址。</p></li><li><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>MOV  AX，SEG  DATA</span></span>
<span class="line"><span>MOV  DS，AX</span></span></code></pre></div></li><li><p>后跟段名时，SEG运算符可以省略。</p></li><li><p>SEG实际上也可以针对该逻辑段中任意一 个符号地址：变量名、标号(已验证！)或者子程序名进行计算</p></li></ul></li><li><p>OFFSET运算符</p><ul><li><p><code>OFFSET 变量名或者标号名</code></p></li><li><p>功能:计算变量名或者标号名代表的存储单元 相对于所在段的段基址的偏移/有效地址。</p></li><li><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>BUF  DB   12，34，56</span></span>
<span class="line"><span>……</span></span>
<span class="line"><span>MOV  AX， SEG 数据段的段名</span></span>
<span class="line"><span>MOV  DS， AX</span></span>
<span class="line"><span>MOV  BX，OFFSET BUF</span></span>
<span class="line"><span>MOV  AL，DS:[BX]</span></span></code></pre></div><ul><li>首先求出BUF的偏移地址并赋给BX，然后对 BX间址取数送到AL，所以(AL)=12。</li></ul></li><li><p>如果仅仅只需访问一个特定的存储单元，那 么最后两条语句可以合并为MOV AL，DS:[BUF]</p></li><li><p>实际上为了利用循环程序处理连续多个存储 单元的数据，经常采用[ BX ]这种寄存器间接寻址的 做法。</p></li></ul></li></ol><h3 id="修改类型属性的运算符ptr" tabindex="-1">修改类型属性的运算符PTR <a class="header-anchor" href="#修改类型属性的运算符ptr" aria-label="Permalink to &quot;修改类型属性的运算符PTR&quot;">​</a></h3><p><code>类型说明符 PTR 符号地址</code></p><ol><li>其中类型说明符包括：</li></ol><ul><li>变量名时：BYTE(字节)，WORD(字)，DWORD(双 字)；</li><li>标号或子程序名时：FAR(远)，NEAR(近)。</li></ul><ol start="2"><li>变量名具有默认的类型属性。 <ul><li>eg:使用DB ABC定义：变量名ABC为字节类型 <ul><li>MOV DS:[BX],12H ；错误 因为无法指明操作数的长度类型</li><li>MOV DS:[ABC],12H ；正确</li></ul></li></ul></li><li>程序中可能出现不匹配的情况，此时：可以 使用PTR运算符：临时修改变量名的类型属性。 <ul><li>eg: 已经指明ABC为字节类型的变量名， <ul><li>那么： MOV AX, ABC ；错</li><li>MOV AX , WORD PTR ABC ；对</li></ul></li></ul></li></ol><h3 id="type运算符" tabindex="-1">TYPE运算符 <a class="header-anchor" href="#type运算符" aria-label="Permalink to &quot;TYPE运算符&quot;">​</a></h3><p><code> TYPE 变量名或者标号名</code></p><ul><li>功能:计算变量或者标号的类型。</li><li>对于字节、字或双字型的变量名返回的值分 别为：1，2，4。</li><li>于NEAR和FAR型的标号分别返回-1，-2.</li></ul><h3 id="数据-变量定义伪指令" tabindex="-1">数据/变量定义伪指令 <a class="header-anchor" href="#数据-变量定义伪指令" aria-label="Permalink to &quot;数据/变量定义伪指令&quot;">​</a></h3><blockquote><p>此类指令的核心功能是：要求编译程序为用户程序分配若干存储单元</p><p>注意：此类伪指令前面可以为存储单元定义变量名。</p></blockquote><h4 id="字节定义伪指令" tabindex="-1">字节定义伪指令 <a class="header-anchor" href="#字节定义伪指令" aria-label="Permalink to &quot;字节定义伪指令&quot;">​</a></h4><p><code> [变量名] DB 一串用逗号间隔的字节型数据</code></p><h5 id="eg1" tabindex="-1">eg1 <a class="header-anchor" href="#eg1" aria-label="Permalink to &quot;eg1&quot;">​</a></h5><ul><li><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>BUF1  DB  55，66H，7*7</span></span>
<span class="line"><span>DB    ?,?</span></span></code></pre></div></li><li><p>DB是Define Byte的缩写,DB伪指令定义的变量名及存储单元的默认属性为 “字节型”。</p></li><li><p><code>*</code>操作 由 由汇编编译器完成</p></li><li><p><code>？</code>代表随机数</p></li></ul><h5 id="eg2" tabindex="-1">eg2 <a class="header-anchor" href="#eg2" aria-label="Permalink to &quot;eg2&quot;">​</a></h5><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>BUF1  DB  55,66H7*7</span></span>
<span class="line"><span>DB    ？，？</span></span>
<span class="line"><span>COUNT1 EQU   $ - BUF1 ;COUNT1为？</span></span>
<span class="line"><span>BUF2   DB  10 DUP( 12H, 2 DUP (12, 34))</span></span>
<span class="line"><span>COUNT2   EQU   $ - BUF2 ;COUNT2为？</span></span>
<span class="line"><span>COUNT3   EQU   $ - BUF1 ;COUNT3为？</span></span></code></pre></div><ul><li>DUP是Duplicate的缩写，翻译为“重复”，DUP左边是 重复系数，右边圆括号中为需要重复设置的数据。DUP操作 符可以嵌套使用</li><li>$运算符的含义：汇编过程中，地址计数器中的内容(地址的当前值)。最常见的用法：与符号常数定义伪指令配合，紧 跟在数据定义伪指令之后，用于统计从某个变量地址开始、 至当前指令为止，所分配的存储单元数目(经常用于循环程序的次数)。</li><li><code>COUNT1 = 5</code>（<code>BUF1</code> 总共 5 个字节）</li><li><code>COUNT2 = 50</code>（<code>BUF2</code> 总共 30 个字节）</li><li><code>COUNT3 = 5 + 50 = 55</code>（<code>BUF1</code> 和 <code>BUF2</code> 总共 55 个字节）</li><li><code>COUNT1</code> 不是一个变量名,不会分配存储单元，它只是一个符号常量，在汇编时由汇编器替换为其值。</li></ul><h4 id="字定义伪指令" tabindex="-1">字定义伪指令 <a class="header-anchor" href="#字定义伪指令" aria-label="Permalink to &quot;字定义伪指令&quot;">​</a></h4><p><code>[变量名] DW 一串用逗号间隔的双字节数</code></p><ul><li><p>DW是Defined Word的缩写，DW伪指令的功能是 通知汇编程序，把所定义的双字节数从指定变量开 始依次存放，每一个双字节数的存放规律是：低位字节存入低地址单元(i单元)，高位字节存入高地址 单元(i+1单元)。</p></li><li><p>出现在DW伪指令中的字符串常数，单引号中只能是一个或两个字符。</p></li><li><p><code>WNUM DW 1234H，56，’AB’，’C’，?</code>经汇编之后，WNUM~WNUM+9存储单 元中存放数据的次序依次是34H，12H，38H，00H，42H，41H，43H， 00H，××，××。</p><ul><li><code>MOV AL, BYTE PTR WNUM+1 </code>AL = 12H</li><li><code>MOV AX, WNUM+1</code> AX = 3812H</li><li><code>WNUM+1</code>只会加1字节</li></ul></li></ul><h4 id="运算符" tabindex="-1">$运算符 <a class="header-anchor" href="#运算符" aria-label="Permalink to &quot;$运算符&quot;">​</a></h4><ul><li>在汇编程序对源程序汇编的过程中,使用地址计数器 来保存当前正在汇编的指令的地址</li><li>地址计数器的值可用$来表示,汇编语言允许用户直 接用$来引用地址计数器的值</li><li>汇编语言程序中，符号“$”表示当前偏移地址值</li><li><code>JMP $-3</code><ul><li>$此处为JMP下一条指令地址， 假设该JMP指令长度为3。故：本指 令实际上跳转回JMP自身！</li><li>构造一个形式上的死循环，实际应用于一个无限循环的中断响应系统。</li></ul></li></ul><h4 id="双字定义伪指令" tabindex="-1">双字定义伪指令 <a class="header-anchor" href="#双字定义伪指令" aria-label="Permalink to &quot;双字定义伪指令&quot;">​</a></h4><p><code>变量名] DD一串用逗号间隔的4字节数</code></p><ul><li>通知汇编程序，把DD定义的数从指定 的变量名开始依次存放，每一数占4个单元， 每一个数的存放规律也是低位字节存入低地 址单元，较高字节存入较高的地址单元。</li></ul><h3 id="段约定语句" tabindex="-1">段约定语句 <a class="header-anchor" href="#段约定语句" aria-label="Permalink to &quot;段约定语句&quot;">​</a></h3><p><code>ASSUME 段寄存器：段名，…，段寄存器：段名</code></p><ul><li><p>例如：<code>ASSUME CS:CODE,DS:DATA</code></p></li><li><p>ASSUME语句是非执行的语句，要求放在代码 段之中、执行寻址操作之前；习惯上，把ASSUME 语句作为代码段的第1条语句</p></li><li><p>ASSUME没有实现初始化，部分段寄存器的初值必须在程序中用指令重新设置</p><ul><li><p>有两个办法可以设置段寄存器的初值</p><p>设DATA为数据段段名:</p><ul><li><p>使用SEG运算符求出逻辑段的段基址赋给段 寄存器，如:</p><p><code>MOV AX，SEG DATA </code></p><p><code>MOV DS，AX</code></p></li><li><p>省略SEG、直接把段名赋给段寄存器，如:</p><p><code>MOV AX，DATA </code></p><p><code>MOV DS，AX</code></p></li></ul></li></ul></li></ul><h2 id="dos系统功能调用" tabindex="-1">DOS系统功能调用 <a class="header-anchor" href="#dos系统功能调用" aria-label="Permalink to &quot;DOS系统功能调用&quot;">​</a></h2><p><code>MOV AH，功能号</code></p><p><code>设置入口参数 </code></p><p><code>INT 21H </code></p><p><code>分析出口参</code></p><ol><li><p>[功能号01H]键盘输入并回显</p><ul><li><p>等待用户从键盘上输入一个字符，有回显， 响应Ctrl-C。此调用的功能是系统扫描键盘 并等待键盘输入一个字符，有键按下时，先 检查是否是Ctrl-C键，若不是则将字符的键 值(ASCII码)送入AL寄存器中，并在屏幕上 显示该字符。</p></li><li><p>入口参数：无。</p></li><li><p>出口参数：AL=按键的ASCII码。</p></li><li><p>下列语句可实现键盘输入。</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>MOV AH，01H        </span></span>
<span class="line"><span>INT 21H</span></span></code></pre></div></li></ul></li><li><p>[功能号02H]在显示器上显示一个字符，响应Ctrl-C。</p><ul><li><p>入口参数：DL=等待显示字符的ASCII码。</p></li><li><p>出口参数：无。</p></li><li><p>在屏幕上显示’A’符号</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>MOV DL，’A’</span></span>
<span class="line"><span>MOV AH，02H</span></span>
<span class="line"><span>INT 21H</span></span></code></pre></div></li><li><p>实验表明，该功能会破坏AL寄存器的值。</p></li><li><p>可以使用不可显示的控制字符。例如，用于实现格式控制的换行(0DH)、回车 (0AH)字符等</p></li></ul></li><li><p>[功能号09H]显示字符串，响应Ctrl-C。</p><ul><li>入口参数：DS:DX=字符串首地址，即待输出 字符串的首字符的逻辑地址 <ul><li>字符串必须以字符‘$’作为结束标志，但’$’ 不会显示在屏幕上。</li></ul></li><li>出口参数：无。</li><li>实验表明，该功能会破坏AL寄存器的值，不 改变其余寄存器及标志寄存器的值。</li></ul></li><li><p>[功能号0AH]等待从键盘上输入一个字符串(必须以 回车符表示结束)，然后存入内存中的数据缓冲区。 有回显，响应Ctrl-C。</p></li></ol><ul><li><p>入口参数：①DS:DX=数据缓冲区首地址；②首字节单元指出允许最大输入的字符串长度(包含 回车符) 。</p></li><li><p>出口参数: ①在缓冲区第二个字节单元存放实际输入字符串的长度(不包含回车符)； ②从第三个字节单元开始存放实际的字符串，其中 一个存储单元存放回车符的ASCII码0DH(十进制的 13)。</p></li><li><p>如果输入的字符个数超过规定值，系统则会发出声 音警告信息。缓冲区不接收超长字符.</p></li><li><p><img src="https://typora5672.oss-cn-chengdu.aliyuncs.com/temp/image-20241226124722513.png" alt="image-20241226124722513"></p></li><li><p>用户键入回车之后，由0AH功能把实际键入 的字符个数(不包括回车符)写入BUF+1单元。</p></li><li><p>键入的字符串从BUF+2单元开始依次存放。 因此，缓冲区的容量要大于(或等于)键入串的 长度(包括回车符)+2</p></li><li><p>eg:</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> BUF  DB  15</span></span>
<span class="line"><span> DB   ?</span></span>
<span class="line"><span> DB 15 DUP(?)  </span></span>
<span class="line"><span>;或者 BUF   DB  15，?，15 DUP(?)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>;允许用户输入14个字符，因为还有1个回车</span></span>
<span class="line"><span></span></span>
<span class="line"><span>MOV  AH，0AH</span></span>
<span class="line"><span>LEA  DX， BUF</span></span>
<span class="line"><span>INT   21H</span></span></code></pre></div></li></ul><ol start="5"><li><p>[功能号4CH]终止当前程序的运行，并把控制权转交给调用它的主程序。</p><ul><li><p>该项功能同时将程序用过的内存空间交还给DOS另 行分配，由被终止程序打开的全部文件都被关闭。</p></li><li><p>即：在用户程序末尾添加以下两条语句：</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>MOV AH，4CH</span></span>
<span class="line"><span>INT 21H</span></span></code></pre></div></li></ul></li></ol><h2 id="宏指令" tabindex="-1">宏指令 <a class="header-anchor" href="#宏指令" aria-label="Permalink to &quot;宏指令&quot;">​</a></h2><blockquote><ul><li>宏指令在形式上是由程序员自己定义的新指令</li><li>但实质上是由CPU指令系统中多条真实指令构成的 一个集合。</li><li>宏指令执行的原理是：汇编时替换为真实指令集合， CPU依次执行宏指令所包含的各条指令语句。</li><li>宏指令分为无参数宏指令与有参数宏指令两种。</li><li>宏指令的定义语句可以放在逻辑段之外，通常都放 在程序的首部，但调用指令仍需放在代码段内。</li><li>对于宏指令，由于每一次宏调用都要进行宏展开， 把宏体中的内容复制一遍，因而用宏编写的程序在 目标代码中会重复出现相同或相似的程序段，占用 内存空间大；所以，频繁调用宏指令会增大目标程序的尺寸</li></ul></blockquote><h3 id="无参数宏指令" tabindex="-1">无参数宏指令 <a class="header-anchor" href="#无参数宏指令" aria-label="Permalink to &quot;无参数宏指令&quot;">​</a></h3><p>格式：</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>宏指令名称  MACRO</span></span>
<span class="line"><span>		宏体</span></span>
<span class="line"><span>		ENDM</span></span></code></pre></div><p>eg-DOS功能调用:</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>RETN MACRO</span></span>
<span class="line"><span> 	MOV  AH，2</span></span>
<span class="line"><span> 	MOV  DL，0DH</span></span>
<span class="line"><span> 	INT  21H</span></span>
<span class="line"><span> 	MOV  DL，0AH</span></span>
<span class="line"><span> 	INT  21H</span></span>
<span class="line"><span> 	ENDM</span></span></code></pre></div><h3 id="有参数宏指令" tabindex="-1">有参数宏指令 <a class="header-anchor" href="#有参数宏指令" aria-label="Permalink to &quot;有参数宏指令&quot;">​</a></h3><p>格式：</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>宏指令名称  MACRO 哑元表</span></span>
<span class="line"><span>		宏体</span></span>
<span class="line"><span>		ENDM</span></span></code></pre></div><h3 id="条件汇编伪指令" tabindex="-1">条件汇编伪指令 <a class="header-anchor" href="#条件汇编伪指令" aria-label="Permalink to &quot;条件汇编伪指令&quot;">​</a></h3><p>格式：</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>格式1:</span></span>
<span class="line"><span>	IF 条件格式</span></span>
<span class="line"><span>	指令集合</span></span>
<span class="line"><span>	ENDIF</span></span>
<span class="line"><span></span></span>
<span class="line"><span>格式2:</span></span>
<span class="line"><span>	IF 条件</span></span>
<span class="line"><span>	指令集合1</span></span>
<span class="line"><span>	ELSE </span></span>
<span class="line"><span>	指令集合2</span></span>
<span class="line"><span>	ENDIF</span></span></code></pre></div>`,63),n=[e];function t(o,c,d,h,u,r){return s(),l("div",null,n)}const m=a(p,[["render",t]]);export{g as __pageData,m as default};
